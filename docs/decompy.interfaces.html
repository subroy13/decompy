<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>decompy.interfaces package &#8212; decompy 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="_static/nature.css?v=601dbdee" />
    <script src="_static/documentation_options.js?v=8d563738"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="decompy.matrix_factorization package" href="decompy.matrix_factorization.html" />
    <link rel="prev" title="decompy package" href="decompy.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="decompy.matrix_factorization.html" title="decompy.matrix_factorization package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="decompy.html" title="decompy package"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">decompy 1.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="decompy.html" accesskey="U">decompy package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">decompy.interfaces package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="decompy-interfaces-package">
<h1>decompy.interfaces package<a class="headerlink" href="#decompy-interfaces-package" title="Link to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
</section>
<section id="module-decompy.interfaces.lsnresult">
<span id="decompy-interfaces-lsnresult-module"></span><h2>decompy.interfaces.lsnresult module<a class="headerlink" href="#module-decompy.interfaces.lsnresult" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.interfaces.lsnresult.LSNResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.interfaces.lsnresult.</span></span><span class="sig-name descname"><span class="pre">LSNResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.lsnresult.LSNResult" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The LSNResult class is a structure for holding the matrix decomposition in form of a low rank matrix L, a sparse matrix S and a small perturbation noise matrix N.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> (<em>np.ndarray</em>) – a numpy ndarray representing the low rank matrix</p></li>
<li><p><strong>S</strong> (<em>np.ndarray</em>) – a sparse matrix that represents the sparse component of a given matrix. This is an optional parameter. If provided, it should be a 2D numpy</p></li>
<li><p><strong>L.</strong> (<em>array with the same shape as the low rank matrix</em>) – </p></li>
<li><p><strong>N</strong> (<em>np.ndarray</em>) – The noise perturbation matrix, which is an optional parameter. If provided, it should be a 2D numpy</p></li>
<li><p><strong>L.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="decompy.interfaces.lsnresult.LSNResult.metrics">
<span class="sig-name descname"><span class="pre">metrics</span></span><a class="headerlink" href="#decompy.interfaces.lsnresult.LSNResult.metrics" title="Link to this definition">¶</a></dt>
<dd><p>a python dictionary object to hold arbitrary values related to convergence metrics of the relevant algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.lsnresult.LSNResult.convergence_metrics">
<span class="sig-name descname"><span class="pre">convergence_metrics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.lsnresult.LSNResult.convergence_metrics" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the convergence metrics from a dictionary called “metrics”.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The method <cite>convergence_metrics</cite> is returning the value of the key “convergence” from the <cite>metrics</cite></p>
</dd>
</dl>
<p>dictionary attribute of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.lsnresult.LSNResult.cumulative_variance">
<span class="sig-name descname"><span class="pre">cumulative_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'identity'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'proportion'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'identity'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.lsnresult.LSNResult.cumulative_variance" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the cumulative variance of singular values and returns either the cumulative
sum or proportion based on the specified type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;identity&quot;</em><em>, </em><em>&quot;proportion&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies the type of cumulative variance to be</p></li>
<li><p><strong>values</strong> (<em>calculated. It can take two possible</em>) – </p></li>
<li><p><strong>selected</strong> (<em>the function returns the cumulative sum</em><em> of </em><em>the singular values. If &quot;proportion&quot; is</em>) – </p></li>
<li><p><strong>function</strong> (<em>the</em>) – </p></li>
<li><p><strong>values.</strong> (<em>returns the cumulative proportion</em><em> of </em><em>variance explained by the singular</em>) – </p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold parameter is a float value that is used to set any singular values that are smaller</p></li>
<li><p><strong>that</strong> (<em>than the threshold to zero. This is done to remove any noise</em><em> or </em><em>small variations in the data</em>) – </p></li>
<li><p><strong>1e-5</strong> (<em>may not be significant. The default value for threshold is</em>) – </p></li>
<li><p><strong>singular</strong> (<em>which means that any</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>a numpy array containing the cumulative sum of the singular values of a matrix, either as an</p>
</dd>
</dl>
<p>identity or as a proportion of the total sum of singular values. The type of output is determined by
the <cite>type</cite> parameter, which can be either “identity” or “proportion”. If the <cite>type</cite> parameter is not
one of these two options, a ValueError is raised. The function</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.lsnresult.LSNResult.estimated_rank">
<span class="sig-name descname"><span class="pre">estimated_rank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.lsnresult.LSNResult.estimated_rank" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the estimated rank of a matrix based on its singular values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold parameter is a float value that is used to determine the minimum value of singular</p></li>
<li><p><strong>below</strong> (<em>values that will be considered in the calculation</em><em> of </em><em>the estimated rank. Any singular value</em>) – </p></li>
<li><p><strong>The</strong> (<em>this threshold will be considered as zero and will not be included in the rank calculation.</em>) – </p></li>
<li><p><strong>1e-5</strong> (<em>default value</em><em> of </em><em>the threshold is</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>estimated_rank</cite> returns the estimated rank of the matrix represented by the instance</p>
</dd>
</dl>
<p>of the <cite>SVD</cite> class. The estimated rank is calculated as the number of singular values that are
greater than or equal to the specified threshold value. The function returns an integer value
representing the estimated rank.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.lsnresult.LSNResult.singular_values">
<span class="sig-name descname"><span class="pre">singular_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.lsnresult.LSNResult.singular_values" title="Link to this definition">¶</a></dt>
<dd><p>This function computes the singular values of a matrix and returns them either as a diagonal matrix
or a 1D array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>as_matrix</strong> (<em>a diagonal matrix with the singular values on the diagonal</em><em>) or </em><em>as a 1D array. If</em>) – A boolean parameter that specifies whether the singular values should be returned as a matrix</p></li>
<li><p><strong>(</strong><strong>i.e.</strong> – </p></li>
<li><p><strong>as_matrix</strong> – </p></li>
<li><p><strong>True</strong> (<em>is</em>) – </p></li>
<li><p><strong>False</strong> (<em>the function returns the singular values as a matrix. If as_matrix is</em>) – </p></li>
<li><p><strong>function</strong> (<em>the</em>) – </p></li>
<li><p><strong>vector.</strong> (<em>returns the singular values as a</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>singular_values</cite> returns the singular values of the matrix <cite>self.L</cite>. If the parameter</p>
</dd>
</dl>
<p><cite>as_matrix</cite> is set to <cite>True</cite>, it returns a diagonal matrix with the singular values on the diagonal.
If <cite>as_matrix</cite> is set to <cite>False</cite>, it returns a 1D array with the singular values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.lsnresult.LSNResult.singular_vectors">
<span class="sig-name descname"><span class="pre">singular_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'left'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'right'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'both'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'left'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.lsnresult.LSNResult.singular_vectors" title="Link to this definition">¶</a></dt>
<dd><p>The function returns the left, right, or both singular vectors of a given matrix using the SVD
method in numpy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;left&quot;</em><em>, </em><em>&quot;right&quot;</em><em>, </em><em>&quot;both&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies which singular vectors to return. It can</p></li>
<li><p><strong>values</strong> (<em>take one</em><em> of </em><em>three</em>) – </p></li>
<li><p><strong>specified</strong> (<em>If &quot;both&quot; is</em>) – </p></li>
<li><p><strong>returned.</strong> (<em>only the right singular vectors</em><em> (</em><em>V</em><em>) </em><em>are</em>) – </p></li>
<li><p><strong>specified</strong> – </p></li>
<li><p><strong>tuple</strong> (<em>both singular values</em><em> (</em><em>U and V</em><em>) </em><em>are returned as a</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>singular_vectors</cite> returns the left singular vectors, right singular vectors, or both</p>
</dd>
</dl>
<p>depending on the value of the <cite>type</cite> parameter. If <cite>type</cite> is “left”, the function returns the left
singular vectors (matrix U), if <cite>type</cite> is “right”, the function returns the right singular vectors
(matrix V), and if <cite>type</cite> is “both”, the function returns both</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.interfaces.pcaresult">
<span id="decompy-interfaces-pcaresult-module"></span><h2>decompy.interfaces.pcaresult module<a class="headerlink" href="#module-decompy.interfaces.pcaresult" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.interfaces.pcaresult.PCAResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.interfaces.pcaresult.</span></span><span class="sig-name descname"><span class="pre">PCAResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.pcaresult.PCAResult" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The PCAResult class is a structure for holding the matrix decomposition in form of location and the principal components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loc</strong> (<em>np.ndarray</em>) – a numpy array representing the location of a point in space</p></li>
<li><p><strong>eval</strong> (<em>np.ndarray</em>) – A 1-dimensional numpy array representing the eigenvalues of a matrix.</p></li>
<li><p><strong>evec</strong> (<em>np.ndarray</em>) – <cite>evec</cite> is a 2D numpy array representing the eigenvectors of a matrix. Each column of the array represents an eigenvector.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="decompy.interfaces.pcaresult.PCAResult.metrics">
<span class="sig-name descname"><span class="pre">metrics</span></span><a class="headerlink" href="#decompy.interfaces.pcaresult.PCAResult.metrics" title="Link to this definition">¶</a></dt>
<dd><p>a python dictionary object to hold arbitrary values related to convergence metrics of the relevant algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.pcaresult.PCAResult.convergence_metrics">
<span class="sig-name descname"><span class="pre">convergence_metrics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.pcaresult.PCAResult.convergence_metrics" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the convergence metrics from a dictionary called “metrics”.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The method <cite>convergence_metrics</cite> is returning the value of the key “convergence” from the <cite>metrics</cite></p>
</dd>
</dl>
<p>dictionary attribute of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.pcaresult.PCAResult.cumulative_variance">
<span class="sig-name descname"><span class="pre">cumulative_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'identity'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'proportion'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'identity'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.pcaresult.PCAResult.cumulative_variance" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the cumulative variance of eigenvalues and returns either the cumulative sum
of squared eigenvalues or the proportion of the cumulative sum of squared eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;identity&quot;</em><em>, </em><em>&quot;proportion&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies the type of cumulative variance to be</p></li>
<li><p><strong>values</strong> (<em>calculated. It can take two possible</em>) – </p></li>
<li><p><strong>selected</strong> (<em>the function returns the cumulative sum</em><em> of </em><em>the squared eigenvalues. If &quot;proportion&quot; is</em>) – </p></li>
<li><p><strong>function</strong> (<em>the</em>) – </p></li>
<li><p><strong>eigenvalues.</strong> (<em>returns the cumulative proportion</em><em> of </em><em>variances explained by the</em>) – </p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold parameter is a float value that is used to filter out small eigenvalues. Any</p></li>
<li><p><strong>and</strong> (<em>eigenvalue smaller than the threshold value will be set to zero. This is done to remove noise</em>) – </p></li>
<li><p><strong>variance.</strong> (<em>numerical instability in the calculation</em><em> of </em><em>the cumulative</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>a numpy array containing the cumulative sum of the squared eigenvalues of the matrix, either as an</p>
</dd>
</dl>
<p>“identity” or “proportion” type. If “identity” is chosen, the function returns the cumulative sum of
the squared eigenvalues. If “proportion” is chosen, the function returns the cumulative sum of the
squared eigenvalues divided by the sum of all squared eigenvalues.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.pcaresult.PCAResult.eigen_values">
<span class="sig-name descname"><span class="pre">eigen_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.pcaresult.PCAResult.eigen_values" title="Link to this definition">¶</a></dt>
<dd><p>The function returns either the diagonal matrix of eigenvalues or the number of eigenvalues of a
given matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>as_matrix</strong> (<em>bool</em><em>, </em><em>optional</em>) – A boolean parameter that determines whether the eigenvalues should be returned as a matrix or a 1D</p></li>
<li><p><strong>True</strong> (<em>array. If as_matrix is</em>) – </p></li>
<li><p><strong>matrix</strong> (<em>the eigenvalues will be returned as a diagonal</em>) – </p></li>
<li><p><strong>the</strong> (<em>where</em>) – </p></li>
<li><p><strong>False</strong> (<em>diagonal elements are the eigenvalues. If as_matrix is</em>) – </p></li>
</ul>
</dd>
</dl>
<p>:param :</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>If <cite>as_matrix</cite> is <cite>True</cite>, the function returns a diagonal matrix of the eigenvalues of the object</p>
</dd>
</dl>
<p><cite>self</cite>. If <cite>as_matrix</cite> is <cite>False</cite>, the function returns the number of eigenvalues of the object
<cite>self</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.pcaresult.PCAResult.eigen_vectors">
<span class="sig-name descname"><span class="pre">eigen_vectors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.pcaresult.PCAResult.eigen_vectors" title="Link to this definition">¶</a></dt>
<dd><p>The function returns the eigenvectors of the PCAResult.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The function <cite>eigen_vectors</cite> is returning the attribute <cite>evec</cite> of the object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.pcaresult.PCAResult.estimated_rank">
<span class="sig-name descname"><span class="pre">estimated_rank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.pcaresult.PCAResult.estimated_rank" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the estimated rank of a matrix based on its eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold parameter is a float value that is used to determine the minimum value of eigenvalues</p></li>
<li><p><strong>this</strong> (<em>that will be considered in the calculation</em><em> of </em><em>the estimated rank. Any eigenvalue below</em>) – </p></li>
<li><p><strong>The</strong> (<em>threshold will be considered as zero and will not be included in the calculation</em><em> of </em><em>the rank.</em>) – </p></li>
<li><p><strong>1e-5</strong> (<em>default value</em><em> of </em><em>the threshold is</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>estimated_rank</cite> returns the estimated rank of the matrix based on the eigenvalues. It</p>
</dd>
</dl>
<p>counts the number of eigenvalues that are greater than or equal to the threshold value (default is
1e-5) and returns that count as the estimated rank.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.pcaresult.PCAResult.location">
<span class="sig-name descname"><span class="pre">location</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.pcaresult.PCAResult.location" title="Link to this definition">¶</a></dt>
<dd><p>The function returns a flattened version of the “loc” attribute of the PCAResult.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The <cite>location</cite> method is returning a flattened version of the <cite>loc</cite> attribute of the object. The</p>
</dd>
</dl>
<p><cite>reshape(-1)</cite> method is used to convert the <cite>loc</cite> attribute into a one-dimensional array.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.interfaces.rankfactorresult">
<span id="decompy-interfaces-rankfactorresult-module"></span><h2>decompy.interfaces.rankfactorresult module<a class="headerlink" href="#module-decompy.interfaces.rankfactorresult" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.interfaces.rankfactorresult.RankFactorizationResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.interfaces.rankfactorresult.</span></span><span class="sig-name descname"><span class="pre">RankFactorizationResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The RankFactorizationResult class is a structure for holding the matrix decomposition
in form of rank factorization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A is a numpy ndarray representing a matrix with 2 dimensions. It is the first of the rank factorized pair</p></li>
<li><p><strong>B</strong> (<em>np.ndarray</em>) – The parameter B is a numpy ndarray representing a matrix. The assert statements in the code ensure</p></li>
<li><p><strong>matrix</strong> (<em>that B has two dimensions and that its second dimension matches the second dimension</em><em> of </em><em>the</em>) – </p></li>
<li><p><strong>A.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="decompy.interfaces.rankfactorresult.RankFactorizationResult.metrics">
<span class="sig-name descname"><span class="pre">metrics</span></span><a class="headerlink" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult.metrics" title="Link to this definition">¶</a></dt>
<dd><p>a python dictionary object to hold arbitrary values related to convergence metrics of the relevant algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.rankfactorresult.RankFactorizationResult.convergence_metrics">
<span class="sig-name descname"><span class="pre">convergence_metrics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult.convergence_metrics" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the convergence metrics from a dictionary called “metrics”.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The method <cite>convergence_metrics</cite> is returning the value of the key “convergence” from the <cite>metrics</cite></p>
</dd>
</dl>
<p>dictionary attribute of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.rankfactorresult.RankFactorizationResult.cumulative_variance">
<span class="sig-name descname"><span class="pre">cumulative_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'identity'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'proportion'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'identity'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult.cumulative_variance" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the cumulative variance of a matrix’s singular values and returns either the
cumulative sum or proportion of the singular values based on the specified type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;identity&quot;</em><em>, </em><em>&quot;proportion&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies the type of cumulative variance to be</p></li>
<li><p><strong>values</strong> (<em>calculated. It can take two possible</em>) – </p></li>
<li><p><strong>function</strong> (<em>the function returns the cumulative sum</em><em> of </em><em>the singular values. If &quot;proportion&quot; is selected the</em>) – </p></li>
<li><p><strong>values.</strong> (<em>returns the cumulative proportion</em><em> of </em><em>the variance explained by the singular</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>a numpy array containing the cumulative sum of the singular values of a matrix. The type of</p>
</dd>
</dl>
<p>cumulative sum returned can be either “identity” or “proportion”, depending on the argument passed
to the function. If “identity” is passed, the function returns the cumulative sum of the singular
values. If “proportion” is passed, the function returns the cumulative proportion of the singular
values</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.rankfactorresult.RankFactorizationResult.estimated_rank">
<span class="sig-name descname"><span class="pre">estimated_rank</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult.estimated_rank" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the rank of the result matrix decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>the rank of the result matrix decomposition.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.rankfactorresult.RankFactorizationResult.singular_values">
<span class="sig-name descname"><span class="pre">singular_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult.singular_values" title="Link to this definition">¶</a></dt>
<dd><p>This function computes the singular values of a matrix product and returns them either as a diagonal
matrix or a list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>as_matrix</strong> (<em>a diagonal matrix with the singular values on the diagonal</em><em>) or </em><em>as a 1D array. If</em>) – A boolean parameter that specifies whether the singular values should be returned as a matrix</p></li>
<li><p><strong>(</strong><strong>i.e.</strong> – </p></li>
<li><p><strong>as_matrix</strong> – </p></li>
<li><p><strong>True</strong> (<em>is</em>) – </p></li>
<li><p><strong>`as</strong> (<em>the function returns the singular values as a matrix. If</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>singular_values</cite> returns the singular values of the matrix product <cite>A &#64; B.T</cite> of the</p>
</dd>
</dl>
<p><cite>MatrixFactorization</cite> object. The singular values are computed using the <cite>numpy.linalg.svd</cite>
function. The function returns either a diagonal matrix of singular values (if <cite>as_matrix</cite> is
<cite>True</cite>) or a 1D array of singular values (if <cite>as_matrix</cite> is</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.rankfactorresult.RankFactorizationResult.singular_vectors">
<span class="sig-name descname"><span class="pre">singular_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'left'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'right'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'both'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'left'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult.singular_vectors" title="Link to this definition">¶</a></dt>
<dd><p>The function computes the singular vectors of a matrix product and returns either the left, right,
or both singular vectors depending on the specified type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;left&quot;</em><em>, </em><em>&quot;right&quot;</em><em>, </em><em>&quot;both&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies which singular vectors to return. It can</p></li>
<li><p><strong>values</strong> (<em>take one</em><em> of </em><em>three</em>) – </p></li>
<li><p><strong>specified</strong> (<em>vectors are returned. If &quot;right&quot; is</em>) – </p></li>
<li><p><strong>right</strong> (<em>only the</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>singular_vectors</cite> returns either the left singular vector <cite>U</cite>, the right singular</p>
</dd>
</dl>
<p>vector <cite>V</cite>, or both <cite>U</cite> and <cite>V</cite>, depending on the value of the <cite>type</cite> parameter. If <cite>type</cite> is not
one of the valid options (“left”, “right”, “both”), a <cite>ValueError</cite> is raised.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.interfaces.svdresult">
<span id="decompy-interfaces-svdresult-module"></span><h2>decompy.interfaces.svdresult module<a class="headerlink" href="#module-decompy.interfaces.svdresult" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.interfaces.svdresult.SVDResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.interfaces.svdresult.</span></span><span class="sig-name descname"><span class="pre">SVDResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.svdresult.SVDResult" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The SVDResult class is a structure for holding the matrix decomposition in form of singular value decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>np.ndarray</em>) – a numpy array representing the left singular vectors of a matrix</p></li>
<li><p><strong>D</strong> (<em>np.ndarray</em>) – A 1-dimensional numpy array containing the singular values of a matrix.</p></li>
<li><p><strong>V</strong> (<em>np.ndarray</em>) – V is a 2D numpy array representing the right singular vectors of a matrix. It is part of the output</p></li>
<li><p><strong>matrix.</strong> (<em>of a singular value decomposition</em><em> (</em><em>SVD</em><em>) </em><em>and is used to reconstruct the original</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="decompy.interfaces.svdresult.SVDResult.metrics">
<span class="sig-name descname"><span class="pre">metrics</span></span><a class="headerlink" href="#decompy.interfaces.svdresult.SVDResult.metrics" title="Link to this definition">¶</a></dt>
<dd><p>a python dictionary object to hold arbitrary values related to convergence metrics of the relevant algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.svdresult.SVDResult.convergence_metrics">
<span class="sig-name descname"><span class="pre">convergence_metrics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.svdresult.SVDResult.convergence_metrics" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the convergence metrics from a dictionary called “metrics”.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The method <cite>convergence_metrics</cite> is returning the value of the key “convergence” from the <cite>metrics</cite></p>
</dd>
</dl>
<p>dictionary attribute of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.svdresult.SVDResult.cumulative_variance">
<span class="sig-name descname"><span class="pre">cumulative_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'identity'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'proportion'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'identity'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.svdresult.SVDResult.cumulative_variance" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the cumulative variance of singular values and returns either the cumulative
sum or proportion based on the specified type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;identity&quot;</em><em>, </em><em>&quot;proportion&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies the type of cumulative variance to be</p></li>
<li><p><strong>values</strong> (<em>calculated. It can take two possible</em>) – </p></li>
<li><p><strong>selected</strong> (<em>the function returns the cumulative sum</em><em> of </em><em>the singular values. If &quot;proportion&quot; is</em>) – </p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold parameter is a float value that is used to set any singular values that are smaller</p></li>
<li><p><strong>of</strong> (<em>than the threshold to zero. This is done to reduce the noise in the data and improve the accuracy</em>) – </p></li>
<li><p><strong>be</strong> (<em>the results. Any singular values that are smaller than the threshold are considered to</em>) – </p></li>
<li><p><strong>set</strong> (<em>insignificant and are therefore</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>a numpy array containing the cumulative sum of the singular values of a matrix, either as an</p>
</dd>
</dl>
<p>identity or as a proportion of the total sum of singular values. The type of output is determined by
the <cite>type</cite> parameter, which can be either “identity” or “proportion”. If the <cite>type</cite> parameter is not
one of these two options, a ValueError is raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.svdresult.SVDResult.estimated_rank">
<span class="sig-name descname"><span class="pre">estimated_rank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.svdresult.SVDResult.estimated_rank" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the estimated rank of a matrix based on its singular values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold parameter is a float value that is used to determine the minimum value of singular</p></li>
<li><p><strong>below</strong> (<em>values that will be considered in the calculation</em><em> of </em><em>the estimated rank. Any singular value</em>) – </p></li>
<li><p><strong>The</strong> (<em>this threshold will be considered as zero and will not be included in the rank calculation.</em>) – </p></li>
<li><p><strong>1</strong> (<em>default value</em><em> of </em><em>the threshold is</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>estimated_rank</cite> returns the estimated rank of the matrix represented by the instance</p>
</dd>
</dl>
<p>of the <cite>SVD</cite> class. The estimated rank is calculated as the number of singular values that are
greater than or equal to the <cite>threshold</cite> value, which is set to <cite>1e-5</cite> by default. The function
returns an integer value representing the estimated rank of the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.svdresult.SVDResult.singular_values">
<span class="sig-name descname"><span class="pre">singular_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.svdresult.SVDResult.singular_values" title="Link to this definition">¶</a></dt>
<dd><p>The function returns the singular values of a matrix either as a diagonal matrix or as a flattened
array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>as_matrix</strong> (<em>bool</em><em>, </em><em>optional</em>) – A boolean parameter that specifies whether the singular values should be returned as a matrix (2D</p></li>
<li><p><strong>True</strong> (<em>array</em><em>) or </em><em>as a 1D array. If as_matrix is</em>) – </p></li>
<li><p><strong>the</strong> (<em>the function returns a diagonal matrix with</em>) – </p></li>
<li><p><strong>False</strong> (<em>singular values on the diagonal. If as_matrix is</em>) – </p></li>
</ul>
</dd>
</dl>
<p>:param :</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The method <cite>singular_values</cite> returns either a diagonal matrix of singular values if <cite>as_matrix</cite> is</p>
</dd>
</dl>
<p><cite>True</cite>, or a 1D array of singular values if <cite>as_matrix</cite> is <cite>False</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.svdresult.SVDResult.singular_vectors">
<span class="sig-name descname"><span class="pre">singular_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'left'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'right'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'both'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'left'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.svdresult.SVDResult.singular_vectors" title="Link to this definition">¶</a></dt>
<dd><p>The function <cite>singular_vectors</cite> returns the left, right, or both singular vectors of a matrix
depending on the input type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;left&quot;</em><em>, </em><em>&quot;right&quot;</em><em>, </em><em>&quot;both&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies which singular vectors to return. It can</p></li>
<li><p><strong>values</strong> (<em>take one</em><em> of </em><em>three</em>) – </p></li>
<li><p><strong>&quot;</strong> (<em>left singular vectors</em><em> (</em><em>stored in the U attribute</em><em>)</em><em>. If</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The <cite>singular_vectors</cite> method returns the left singular vectors if the <cite>type</cite> parameter is set to</p>
</dd>
</dl>
<p>“left”, the right singular vectors if <cite>type</cite> is set to “right”, both left and right singular vectors
if <cite>type</cite> is set to “both”. If <cite>type</cite> is set to any other value, a <cite>ValueError</cite> is raised.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.interfaces">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-decompy.interfaces" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.interfaces.LSNResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.interfaces.</span></span><span class="sig-name descname"><span class="pre">LSNResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.LSNResult" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The LSNResult class is a structure for holding the matrix decomposition in form of a low rank matrix L, a sparse matrix S and a small perturbation noise matrix N.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> (<em>np.ndarray</em>) – a numpy ndarray representing the low rank matrix</p></li>
<li><p><strong>S</strong> (<em>np.ndarray</em>) – a sparse matrix that represents the sparse component of a given matrix. This is an optional parameter. If provided, it should be a 2D numpy</p></li>
<li><p><strong>L.</strong> (<em>array with the same shape as the low rank matrix</em>) – </p></li>
<li><p><strong>N</strong> (<em>np.ndarray</em>) – The noise perturbation matrix, which is an optional parameter. If provided, it should be a 2D numpy</p></li>
<li><p><strong>L.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="decompy.interfaces.LSNResult.metrics">
<span class="sig-name descname"><span class="pre">metrics</span></span><a class="headerlink" href="#decompy.interfaces.LSNResult.metrics" title="Link to this definition">¶</a></dt>
<dd><p>a python dictionary object to hold arbitrary values related to convergence metrics of the relevant algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.LSNResult.convergence_metrics">
<span class="sig-name descname"><span class="pre">convergence_metrics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.LSNResult.convergence_metrics" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the convergence metrics from a dictionary called “metrics”.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The method <cite>convergence_metrics</cite> is returning the value of the key “convergence” from the <cite>metrics</cite></p>
</dd>
</dl>
<p>dictionary attribute of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.LSNResult.cumulative_variance">
<span class="sig-name descname"><span class="pre">cumulative_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'identity'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'proportion'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'identity'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.LSNResult.cumulative_variance" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the cumulative variance of singular values and returns either the cumulative
sum or proportion based on the specified type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;identity&quot;</em><em>, </em><em>&quot;proportion&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies the type of cumulative variance to be</p></li>
<li><p><strong>values</strong> (<em>calculated. It can take two possible</em>) – </p></li>
<li><p><strong>selected</strong> (<em>the function returns the cumulative sum</em><em> of </em><em>the singular values. If &quot;proportion&quot; is</em>) – </p></li>
<li><p><strong>function</strong> (<em>the</em>) – </p></li>
<li><p><strong>values.</strong> (<em>returns the cumulative proportion</em><em> of </em><em>variance explained by the singular</em>) – </p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold parameter is a float value that is used to set any singular values that are smaller</p></li>
<li><p><strong>that</strong> (<em>than the threshold to zero. This is done to remove any noise</em><em> or </em><em>small variations in the data</em>) – </p></li>
<li><p><strong>1e-5</strong> (<em>may not be significant. The default value for threshold is</em>) – </p></li>
<li><p><strong>singular</strong> (<em>which means that any</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>a numpy array containing the cumulative sum of the singular values of a matrix, either as an</p>
</dd>
</dl>
<p>identity or as a proportion of the total sum of singular values. The type of output is determined by
the <cite>type</cite> parameter, which can be either “identity” or “proportion”. If the <cite>type</cite> parameter is not
one of these two options, a ValueError is raised. The function</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.LSNResult.estimated_rank">
<span class="sig-name descname"><span class="pre">estimated_rank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.LSNResult.estimated_rank" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the estimated rank of a matrix based on its singular values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold parameter is a float value that is used to determine the minimum value of singular</p></li>
<li><p><strong>below</strong> (<em>values that will be considered in the calculation</em><em> of </em><em>the estimated rank. Any singular value</em>) – </p></li>
<li><p><strong>The</strong> (<em>this threshold will be considered as zero and will not be included in the rank calculation.</em>) – </p></li>
<li><p><strong>1e-5</strong> (<em>default value</em><em> of </em><em>the threshold is</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>estimated_rank</cite> returns the estimated rank of the matrix represented by the instance</p>
</dd>
</dl>
<p>of the <cite>SVD</cite> class. The estimated rank is calculated as the number of singular values that are
greater than or equal to the specified threshold value. The function returns an integer value
representing the estimated rank.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.LSNResult.singular_values">
<span class="sig-name descname"><span class="pre">singular_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.LSNResult.singular_values" title="Link to this definition">¶</a></dt>
<dd><p>This function computes the singular values of a matrix and returns them either as a diagonal matrix
or a 1D array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>as_matrix</strong> (<em>a diagonal matrix with the singular values on the diagonal</em><em>) or </em><em>as a 1D array. If</em>) – A boolean parameter that specifies whether the singular values should be returned as a matrix</p></li>
<li><p><strong>(</strong><strong>i.e.</strong> – </p></li>
<li><p><strong>as_matrix</strong> – </p></li>
<li><p><strong>True</strong> (<em>is</em>) – </p></li>
<li><p><strong>False</strong> (<em>the function returns the singular values as a matrix. If as_matrix is</em>) – </p></li>
<li><p><strong>function</strong> (<em>the</em>) – </p></li>
<li><p><strong>vector.</strong> (<em>returns the singular values as a</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>singular_values</cite> returns the singular values of the matrix <cite>self.L</cite>. If the parameter</p>
</dd>
</dl>
<p><cite>as_matrix</cite> is set to <cite>True</cite>, it returns a diagonal matrix with the singular values on the diagonal.
If <cite>as_matrix</cite> is set to <cite>False</cite>, it returns a 1D array with the singular values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.LSNResult.singular_vectors">
<span class="sig-name descname"><span class="pre">singular_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'left'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'right'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'both'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'left'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.LSNResult.singular_vectors" title="Link to this definition">¶</a></dt>
<dd><p>The function returns the left, right, or both singular vectors of a given matrix using the SVD
method in numpy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;left&quot;</em><em>, </em><em>&quot;right&quot;</em><em>, </em><em>&quot;both&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies which singular vectors to return. It can</p></li>
<li><p><strong>values</strong> (<em>take one</em><em> of </em><em>three</em>) – </p></li>
<li><p><strong>specified</strong> (<em>If &quot;both&quot; is</em>) – </p></li>
<li><p><strong>returned.</strong> (<em>only the right singular vectors</em><em> (</em><em>V</em><em>) </em><em>are</em>) – </p></li>
<li><p><strong>specified</strong> – </p></li>
<li><p><strong>tuple</strong> (<em>both singular values</em><em> (</em><em>U and V</em><em>) </em><em>are returned as a</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>singular_vectors</cite> returns the left singular vectors, right singular vectors, or both</p>
</dd>
</dl>
<p>depending on the value of the <cite>type</cite> parameter. If <cite>type</cite> is “left”, the function returns the left
singular vectors (matrix U), if <cite>type</cite> is “right”, the function returns the right singular vectors
(matrix V), and if <cite>type</cite> is “both”, the function returns both</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.interfaces.PCAResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.interfaces.</span></span><span class="sig-name descname"><span class="pre">PCAResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.PCAResult" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The PCAResult class is a structure for holding the matrix decomposition in form of location and the principal components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loc</strong> (<em>np.ndarray</em>) – a numpy array representing the location of a point in space</p></li>
<li><p><strong>eval</strong> (<em>np.ndarray</em>) – A 1-dimensional numpy array representing the eigenvalues of a matrix.</p></li>
<li><p><strong>evec</strong> (<em>np.ndarray</em>) – <cite>evec</cite> is a 2D numpy array representing the eigenvectors of a matrix. Each column of the array represents an eigenvector.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="decompy.interfaces.PCAResult.metrics">
<span class="sig-name descname"><span class="pre">metrics</span></span><a class="headerlink" href="#decompy.interfaces.PCAResult.metrics" title="Link to this definition">¶</a></dt>
<dd><p>a python dictionary object to hold arbitrary values related to convergence metrics of the relevant algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.PCAResult.convergence_metrics">
<span class="sig-name descname"><span class="pre">convergence_metrics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.PCAResult.convergence_metrics" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the convergence metrics from a dictionary called “metrics”.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The method <cite>convergence_metrics</cite> is returning the value of the key “convergence” from the <cite>metrics</cite></p>
</dd>
</dl>
<p>dictionary attribute of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.PCAResult.cumulative_variance">
<span class="sig-name descname"><span class="pre">cumulative_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'identity'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'proportion'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'identity'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.PCAResult.cumulative_variance" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the cumulative variance of eigenvalues and returns either the cumulative sum
of squared eigenvalues or the proportion of the cumulative sum of squared eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;identity&quot;</em><em>, </em><em>&quot;proportion&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies the type of cumulative variance to be</p></li>
<li><p><strong>values</strong> (<em>calculated. It can take two possible</em>) – </p></li>
<li><p><strong>selected</strong> (<em>the function returns the cumulative sum</em><em> of </em><em>the squared eigenvalues. If &quot;proportion&quot; is</em>) – </p></li>
<li><p><strong>function</strong> (<em>the</em>) – </p></li>
<li><p><strong>eigenvalues.</strong> (<em>returns the cumulative proportion</em><em> of </em><em>variances explained by the</em>) – </p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold parameter is a float value that is used to filter out small eigenvalues. Any</p></li>
<li><p><strong>and</strong> (<em>eigenvalue smaller than the threshold value will be set to zero. This is done to remove noise</em>) – </p></li>
<li><p><strong>variance.</strong> (<em>numerical instability in the calculation</em><em> of </em><em>the cumulative</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>a numpy array containing the cumulative sum of the squared eigenvalues of the matrix, either as an</p>
</dd>
</dl>
<p>“identity” or “proportion” type. If “identity” is chosen, the function returns the cumulative sum of
the squared eigenvalues. If “proportion” is chosen, the function returns the cumulative sum of the
squared eigenvalues divided by the sum of all squared eigenvalues.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.PCAResult.eigen_values">
<span class="sig-name descname"><span class="pre">eigen_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.PCAResult.eigen_values" title="Link to this definition">¶</a></dt>
<dd><p>The function returns either the diagonal matrix of eigenvalues or the number of eigenvalues of a
given matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>as_matrix</strong> (<em>bool</em><em>, </em><em>optional</em>) – A boolean parameter that determines whether the eigenvalues should be returned as a matrix or a 1D</p></li>
<li><p><strong>True</strong> (<em>array. If as_matrix is</em>) – </p></li>
<li><p><strong>matrix</strong> (<em>the eigenvalues will be returned as a diagonal</em>) – </p></li>
<li><p><strong>the</strong> (<em>where</em>) – </p></li>
<li><p><strong>False</strong> (<em>diagonal elements are the eigenvalues. If as_matrix is</em>) – </p></li>
</ul>
</dd>
</dl>
<p>:param :</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>If <cite>as_matrix</cite> is <cite>True</cite>, the function returns a diagonal matrix of the eigenvalues of the object</p>
</dd>
</dl>
<p><cite>self</cite>. If <cite>as_matrix</cite> is <cite>False</cite>, the function returns the number of eigenvalues of the object
<cite>self</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.PCAResult.eigen_vectors">
<span class="sig-name descname"><span class="pre">eigen_vectors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.PCAResult.eigen_vectors" title="Link to this definition">¶</a></dt>
<dd><p>The function returns the eigenvectors of the PCAResult.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The function <cite>eigen_vectors</cite> is returning the attribute <cite>evec</cite> of the object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.PCAResult.estimated_rank">
<span class="sig-name descname"><span class="pre">estimated_rank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.PCAResult.estimated_rank" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the estimated rank of a matrix based on its eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold parameter is a float value that is used to determine the minimum value of eigenvalues</p></li>
<li><p><strong>this</strong> (<em>that will be considered in the calculation</em><em> of </em><em>the estimated rank. Any eigenvalue below</em>) – </p></li>
<li><p><strong>The</strong> (<em>threshold will be considered as zero and will not be included in the calculation</em><em> of </em><em>the rank.</em>) – </p></li>
<li><p><strong>1e-5</strong> (<em>default value</em><em> of </em><em>the threshold is</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>estimated_rank</cite> returns the estimated rank of the matrix based on the eigenvalues. It</p>
</dd>
</dl>
<p>counts the number of eigenvalues that are greater than or equal to the threshold value (default is
1e-5) and returns that count as the estimated rank.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.PCAResult.location">
<span class="sig-name descname"><span class="pre">location</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.PCAResult.location" title="Link to this definition">¶</a></dt>
<dd><p>The function returns a flattened version of the “loc” attribute of the PCAResult.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The <cite>location</cite> method is returning a flattened version of the <cite>loc</cite> attribute of the object. The</p>
</dd>
</dl>
<p><cite>reshape(-1)</cite> method is used to convert the <cite>loc</cite> attribute into a one-dimensional array.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.interfaces.RankFactorizationResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.interfaces.</span></span><span class="sig-name descname"><span class="pre">RankFactorizationResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.RankFactorizationResult" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The RankFactorizationResult class is a structure for holding the matrix decomposition
in form of rank factorization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A is a numpy ndarray representing a matrix with 2 dimensions. It is the first of the rank factorized pair</p></li>
<li><p><strong>B</strong> (<em>np.ndarray</em>) – The parameter B is a numpy ndarray representing a matrix. The assert statements in the code ensure</p></li>
<li><p><strong>matrix</strong> (<em>that B has two dimensions and that its second dimension matches the second dimension</em><em> of </em><em>the</em>) – </p></li>
<li><p><strong>A.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="decompy.interfaces.RankFactorizationResult.metrics">
<span class="sig-name descname"><span class="pre">metrics</span></span><a class="headerlink" href="#decompy.interfaces.RankFactorizationResult.metrics" title="Link to this definition">¶</a></dt>
<dd><p>a python dictionary object to hold arbitrary values related to convergence metrics of the relevant algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.RankFactorizationResult.convergence_metrics">
<span class="sig-name descname"><span class="pre">convergence_metrics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.RankFactorizationResult.convergence_metrics" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the convergence metrics from a dictionary called “metrics”.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The method <cite>convergence_metrics</cite> is returning the value of the key “convergence” from the <cite>metrics</cite></p>
</dd>
</dl>
<p>dictionary attribute of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.RankFactorizationResult.cumulative_variance">
<span class="sig-name descname"><span class="pre">cumulative_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'identity'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'proportion'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'identity'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.RankFactorizationResult.cumulative_variance" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the cumulative variance of a matrix’s singular values and returns either the
cumulative sum or proportion of the singular values based on the specified type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;identity&quot;</em><em>, </em><em>&quot;proportion&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies the type of cumulative variance to be</p></li>
<li><p><strong>values</strong> (<em>calculated. It can take two possible</em>) – </p></li>
<li><p><strong>function</strong> (<em>the function returns the cumulative sum</em><em> of </em><em>the singular values. If &quot;proportion&quot; is selected the</em>) – </p></li>
<li><p><strong>values.</strong> (<em>returns the cumulative proportion</em><em> of </em><em>the variance explained by the singular</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>a numpy array containing the cumulative sum of the singular values of a matrix. The type of</p>
</dd>
</dl>
<p>cumulative sum returned can be either “identity” or “proportion”, depending on the argument passed
to the function. If “identity” is passed, the function returns the cumulative sum of the singular
values. If “proportion” is passed, the function returns the cumulative proportion of the singular
values</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.RankFactorizationResult.estimated_rank">
<span class="sig-name descname"><span class="pre">estimated_rank</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.RankFactorizationResult.estimated_rank" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the rank of the result matrix decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>the rank of the result matrix decomposition.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.RankFactorizationResult.singular_values">
<span class="sig-name descname"><span class="pre">singular_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.RankFactorizationResult.singular_values" title="Link to this definition">¶</a></dt>
<dd><p>This function computes the singular values of a matrix product and returns them either as a diagonal
matrix or a list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>as_matrix</strong> (<em>a diagonal matrix with the singular values on the diagonal</em><em>) or </em><em>as a 1D array. If</em>) – A boolean parameter that specifies whether the singular values should be returned as a matrix</p></li>
<li><p><strong>(</strong><strong>i.e.</strong> – </p></li>
<li><p><strong>as_matrix</strong> – </p></li>
<li><p><strong>True</strong> (<em>is</em>) – </p></li>
<li><p><strong>`as</strong> (<em>the function returns the singular values as a matrix. If</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>singular_values</cite> returns the singular values of the matrix product <cite>A &#64; B.T</cite> of the</p>
</dd>
</dl>
<p><cite>MatrixFactorization</cite> object. The singular values are computed using the <cite>numpy.linalg.svd</cite>
function. The function returns either a diagonal matrix of singular values (if <cite>as_matrix</cite> is
<cite>True</cite>) or a 1D array of singular values (if <cite>as_matrix</cite> is</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.RankFactorizationResult.singular_vectors">
<span class="sig-name descname"><span class="pre">singular_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'left'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'right'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'both'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'left'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.RankFactorizationResult.singular_vectors" title="Link to this definition">¶</a></dt>
<dd><p>The function computes the singular vectors of a matrix product and returns either the left, right,
or both singular vectors depending on the specified type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;left&quot;</em><em>, </em><em>&quot;right&quot;</em><em>, </em><em>&quot;both&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies which singular vectors to return. It can</p></li>
<li><p><strong>values</strong> (<em>take one</em><em> of </em><em>three</em>) – </p></li>
<li><p><strong>specified</strong> (<em>vectors are returned. If &quot;right&quot; is</em>) – </p></li>
<li><p><strong>right</strong> (<em>only the</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>singular_vectors</cite> returns either the left singular vector <cite>U</cite>, the right singular</p>
</dd>
</dl>
<p>vector <cite>V</cite>, or both <cite>U</cite> and <cite>V</cite>, depending on the value of the <cite>type</cite> parameter. If <cite>type</cite> is not
one of the valid options (“left”, “right”, “both”), a <cite>ValueError</cite> is raised.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.interfaces.SVDResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.interfaces.</span></span><span class="sig-name descname"><span class="pre">SVDResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.SVDResult" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The SVDResult class is a structure for holding the matrix decomposition in form of singular value decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>np.ndarray</em>) – a numpy array representing the left singular vectors of a matrix</p></li>
<li><p><strong>D</strong> (<em>np.ndarray</em>) – A 1-dimensional numpy array containing the singular values of a matrix.</p></li>
<li><p><strong>V</strong> (<em>np.ndarray</em>) – V is a 2D numpy array representing the right singular vectors of a matrix. It is part of the output</p></li>
<li><p><strong>matrix.</strong> (<em>of a singular value decomposition</em><em> (</em><em>SVD</em><em>) </em><em>and is used to reconstruct the original</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="decompy.interfaces.SVDResult.metrics">
<span class="sig-name descname"><span class="pre">metrics</span></span><a class="headerlink" href="#decompy.interfaces.SVDResult.metrics" title="Link to this definition">¶</a></dt>
<dd><p>a python dictionary object to hold arbitrary values related to convergence metrics of the relevant algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.SVDResult.convergence_metrics">
<span class="sig-name descname"><span class="pre">convergence_metrics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.SVDResult.convergence_metrics" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the convergence metrics from a dictionary called “metrics”.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The method <cite>convergence_metrics</cite> is returning the value of the key “convergence” from the <cite>metrics</cite></p>
</dd>
</dl>
<p>dictionary attribute of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.SVDResult.cumulative_variance">
<span class="sig-name descname"><span class="pre">cumulative_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'identity'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'proportion'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'identity'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.SVDResult.cumulative_variance" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the cumulative variance of singular values and returns either the cumulative
sum or proportion based on the specified type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;identity&quot;</em><em>, </em><em>&quot;proportion&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies the type of cumulative variance to be</p></li>
<li><p><strong>values</strong> (<em>calculated. It can take two possible</em>) – </p></li>
<li><p><strong>selected</strong> (<em>the function returns the cumulative sum</em><em> of </em><em>the singular values. If &quot;proportion&quot; is</em>) – </p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold parameter is a float value that is used to set any singular values that are smaller</p></li>
<li><p><strong>of</strong> (<em>than the threshold to zero. This is done to reduce the noise in the data and improve the accuracy</em>) – </p></li>
<li><p><strong>be</strong> (<em>the results. Any singular values that are smaller than the threshold are considered to</em>) – </p></li>
<li><p><strong>set</strong> (<em>insignificant and are therefore</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>a numpy array containing the cumulative sum of the singular values of a matrix, either as an</p>
</dd>
</dl>
<p>identity or as a proportion of the total sum of singular values. The type of output is determined by
the <cite>type</cite> parameter, which can be either “identity” or “proportion”. If the <cite>type</cite> parameter is not
one of these two options, a ValueError is raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.SVDResult.estimated_rank">
<span class="sig-name descname"><span class="pre">estimated_rank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.SVDResult.estimated_rank" title="Link to this definition">¶</a></dt>
<dd><p>The function calculates the estimated rank of a matrix based on its singular values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold parameter is a float value that is used to determine the minimum value of singular</p></li>
<li><p><strong>below</strong> (<em>values that will be considered in the calculation</em><em> of </em><em>the estimated rank. Any singular value</em>) – </p></li>
<li><p><strong>The</strong> (<em>this threshold will be considered as zero and will not be included in the rank calculation.</em>) – </p></li>
<li><p><strong>1</strong> (<em>default value</em><em> of </em><em>the threshold is</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The function <cite>estimated_rank</cite> returns the estimated rank of the matrix represented by the instance</p>
</dd>
</dl>
<p>of the <cite>SVD</cite> class. The estimated rank is calculated as the number of singular values that are
greater than or equal to the <cite>threshold</cite> value, which is set to <cite>1e-5</cite> by default. The function
returns an integer value representing the estimated rank of the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.SVDResult.singular_values">
<span class="sig-name descname"><span class="pre">singular_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.SVDResult.singular_values" title="Link to this definition">¶</a></dt>
<dd><p>The function returns the singular values of a matrix either as a diagonal matrix or as a flattened
array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>as_matrix</strong> (<em>bool</em><em>, </em><em>optional</em>) – A boolean parameter that specifies whether the singular values should be returned as a matrix (2D</p></li>
<li><p><strong>True</strong> (<em>array</em><em>) or </em><em>as a 1D array. If as_matrix is</em>) – </p></li>
<li><p><strong>the</strong> (<em>the function returns a diagonal matrix with</em>) – </p></li>
<li><p><strong>False</strong> (<em>singular values on the diagonal. If as_matrix is</em>) – </p></li>
</ul>
</dd>
</dl>
<p>:param :</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>The method <cite>singular_values</cite> returns either a diagonal matrix of singular values if <cite>as_matrix</cite> is</p>
</dd>
</dl>
<p><cite>True</cite>, or a 1D array of singular values if <cite>as_matrix</cite> is <cite>False</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.interfaces.SVDResult.singular_vectors">
<span class="sig-name descname"><span class="pre">singular_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'left'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'right'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'both'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'left'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.interfaces.SVDResult.singular_vectors" title="Link to this definition">¶</a></dt>
<dd><p>The function <cite>singular_vectors</cite> returns the left, right, or both singular vectors of a matrix
depending on the input type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>Literal</em><em>[</em><em>&quot;left&quot;</em><em>, </em><em>&quot;right&quot;</em><em>, </em><em>&quot;both&quot;</em><em>]</em><em>, </em><em>optional</em>) – The <cite>type</cite> parameter is a string literal that specifies which singular vectors to return. It can</p></li>
<li><p><strong>values</strong> (<em>take one</em><em> of </em><em>three</em>) – </p></li>
<li><p><strong>&quot;</strong> (<em>left singular vectors</em><em> (</em><em>stored in the U attribute</em><em>)</em><em>. If</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The <cite>singular_vectors</cite> method returns the left singular vectors if the <cite>type</cite> parameter is set to</p>
</dd>
</dl>
<p>“left”, the right singular vectors if <cite>type</cite> is set to “right”, both left and right singular vectors
if <cite>type</cite> is set to “both”. If <cite>type</cite> is set to any other value, a <cite>ValueError</cite> is raised.</p>
</dd></dl>

</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">decompy.interfaces package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-decompy.interfaces.lsnresult">decompy.interfaces.lsnresult module</a><ul>
<li><a class="reference internal" href="#decompy.interfaces.lsnresult.LSNResult"><code class="docutils literal notranslate"><span class="pre">LSNResult</span></code></a><ul>
<li><a class="reference internal" href="#decompy.interfaces.lsnresult.LSNResult.metrics"><code class="docutils literal notranslate"><span class="pre">LSNResult.metrics</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.lsnresult.LSNResult.convergence_metrics"><code class="docutils literal notranslate"><span class="pre">LSNResult.convergence_metrics()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.lsnresult.LSNResult.cumulative_variance"><code class="docutils literal notranslate"><span class="pre">LSNResult.cumulative_variance()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.lsnresult.LSNResult.estimated_rank"><code class="docutils literal notranslate"><span class="pre">LSNResult.estimated_rank()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.lsnresult.LSNResult.singular_values"><code class="docutils literal notranslate"><span class="pre">LSNResult.singular_values()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.lsnresult.LSNResult.singular_vectors"><code class="docutils literal notranslate"><span class="pre">LSNResult.singular_vectors()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.interfaces.pcaresult">decompy.interfaces.pcaresult module</a><ul>
<li><a class="reference internal" href="#decompy.interfaces.pcaresult.PCAResult"><code class="docutils literal notranslate"><span class="pre">PCAResult</span></code></a><ul>
<li><a class="reference internal" href="#decompy.interfaces.pcaresult.PCAResult.metrics"><code class="docutils literal notranslate"><span class="pre">PCAResult.metrics</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.pcaresult.PCAResult.convergence_metrics"><code class="docutils literal notranslate"><span class="pre">PCAResult.convergence_metrics()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.pcaresult.PCAResult.cumulative_variance"><code class="docutils literal notranslate"><span class="pre">PCAResult.cumulative_variance()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.pcaresult.PCAResult.eigen_values"><code class="docutils literal notranslate"><span class="pre">PCAResult.eigen_values()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.pcaresult.PCAResult.eigen_vectors"><code class="docutils literal notranslate"><span class="pre">PCAResult.eigen_vectors()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.pcaresult.PCAResult.estimated_rank"><code class="docutils literal notranslate"><span class="pre">PCAResult.estimated_rank()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.pcaresult.PCAResult.location"><code class="docutils literal notranslate"><span class="pre">PCAResult.location()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.interfaces.rankfactorresult">decompy.interfaces.rankfactorresult module</a><ul>
<li><a class="reference internal" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult</span></code></a><ul>
<li><a class="reference internal" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult.metrics"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult.metrics</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult.convergence_metrics"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult.convergence_metrics()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult.cumulative_variance"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult.cumulative_variance()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult.estimated_rank"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult.estimated_rank()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult.singular_values"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult.singular_values()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.rankfactorresult.RankFactorizationResult.singular_vectors"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult.singular_vectors()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.interfaces.svdresult">decompy.interfaces.svdresult module</a><ul>
<li><a class="reference internal" href="#decompy.interfaces.svdresult.SVDResult"><code class="docutils literal notranslate"><span class="pre">SVDResult</span></code></a><ul>
<li><a class="reference internal" href="#decompy.interfaces.svdresult.SVDResult.metrics"><code class="docutils literal notranslate"><span class="pre">SVDResult.metrics</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.svdresult.SVDResult.convergence_metrics"><code class="docutils literal notranslate"><span class="pre">SVDResult.convergence_metrics()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.svdresult.SVDResult.cumulative_variance"><code class="docutils literal notranslate"><span class="pre">SVDResult.cumulative_variance()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.svdresult.SVDResult.estimated_rank"><code class="docutils literal notranslate"><span class="pre">SVDResult.estimated_rank()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.svdresult.SVDResult.singular_values"><code class="docutils literal notranslate"><span class="pre">SVDResult.singular_values()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.svdresult.SVDResult.singular_vectors"><code class="docutils literal notranslate"><span class="pre">SVDResult.singular_vectors()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.interfaces">Module contents</a><ul>
<li><a class="reference internal" href="#decompy.interfaces.LSNResult"><code class="docutils literal notranslate"><span class="pre">LSNResult</span></code></a><ul>
<li><a class="reference internal" href="#decompy.interfaces.LSNResult.metrics"><code class="docutils literal notranslate"><span class="pre">LSNResult.metrics</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.LSNResult.convergence_metrics"><code class="docutils literal notranslate"><span class="pre">LSNResult.convergence_metrics()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.LSNResult.cumulative_variance"><code class="docutils literal notranslate"><span class="pre">LSNResult.cumulative_variance()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.LSNResult.estimated_rank"><code class="docutils literal notranslate"><span class="pre">LSNResult.estimated_rank()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.LSNResult.singular_values"><code class="docutils literal notranslate"><span class="pre">LSNResult.singular_values()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.LSNResult.singular_vectors"><code class="docutils literal notranslate"><span class="pre">LSNResult.singular_vectors()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.interfaces.PCAResult"><code class="docutils literal notranslate"><span class="pre">PCAResult</span></code></a><ul>
<li><a class="reference internal" href="#decompy.interfaces.PCAResult.metrics"><code class="docutils literal notranslate"><span class="pre">PCAResult.metrics</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.PCAResult.convergence_metrics"><code class="docutils literal notranslate"><span class="pre">PCAResult.convergence_metrics()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.PCAResult.cumulative_variance"><code class="docutils literal notranslate"><span class="pre">PCAResult.cumulative_variance()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.PCAResult.eigen_values"><code class="docutils literal notranslate"><span class="pre">PCAResult.eigen_values()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.PCAResult.eigen_vectors"><code class="docutils literal notranslate"><span class="pre">PCAResult.eigen_vectors()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.PCAResult.estimated_rank"><code class="docutils literal notranslate"><span class="pre">PCAResult.estimated_rank()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.PCAResult.location"><code class="docutils literal notranslate"><span class="pre">PCAResult.location()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.interfaces.RankFactorizationResult"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult</span></code></a><ul>
<li><a class="reference internal" href="#decompy.interfaces.RankFactorizationResult.metrics"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult.metrics</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.RankFactorizationResult.convergence_metrics"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult.convergence_metrics()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.RankFactorizationResult.cumulative_variance"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult.cumulative_variance()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.RankFactorizationResult.estimated_rank"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult.estimated_rank()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.RankFactorizationResult.singular_values"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult.singular_values()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.RankFactorizationResult.singular_vectors"><code class="docutils literal notranslate"><span class="pre">RankFactorizationResult.singular_vectors()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.interfaces.SVDResult"><code class="docutils literal notranslate"><span class="pre">SVDResult</span></code></a><ul>
<li><a class="reference internal" href="#decompy.interfaces.SVDResult.metrics"><code class="docutils literal notranslate"><span class="pre">SVDResult.metrics</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.SVDResult.convergence_metrics"><code class="docutils literal notranslate"><span class="pre">SVDResult.convergence_metrics()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.SVDResult.cumulative_variance"><code class="docutils literal notranslate"><span class="pre">SVDResult.cumulative_variance()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.SVDResult.estimated_rank"><code class="docutils literal notranslate"><span class="pre">SVDResult.estimated_rank()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.SVDResult.singular_values"><code class="docutils literal notranslate"><span class="pre">SVDResult.singular_values()</span></code></a></li>
<li><a class="reference internal" href="#decompy.interfaces.SVDResult.singular_vectors"><code class="docutils literal notranslate"><span class="pre">SVDResult.singular_vectors()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="decompy.html"
                          title="previous chapter">decompy package</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="decompy.matrix_factorization.html"
                          title="next chapter">decompy.matrix_factorization package</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/decompy.interfaces.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="decompy.matrix_factorization.html" title="decompy.matrix_factorization package"
             >next</a> |</li>
        <li class="right" >
          <a href="decompy.html" title="decompy package"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">decompy 1.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="decompy.html" >decompy package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">decompy.interfaces package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Subhrajyoty Roy.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>