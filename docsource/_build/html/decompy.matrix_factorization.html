<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>decompy.matrix_factorization package &#8212; decompy 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="_static/nature.css?v=601dbdee" />
    <script src="_static/documentation_options.js?v=8d563738"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="decompy.rankmethods package" href="decompy.rankmethods.html" />
    <link rel="prev" title="decompy.interfaces package" href="decompy.interfaces.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="decompy.rankmethods.html" title="decompy.rankmethods package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="decompy.interfaces.html" title="decompy.interfaces package"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">decompy 1.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="decompy.html" accesskey="U">decompy package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">decompy.matrix_factorization package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="decompy-matrix-factorization-package">
<h1>decompy.matrix_factorization package<a class="headerlink" href="#decompy-matrix-factorization-package" title="Link to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
</section>
<section id="module-decompy.matrix_factorization.adm">
<span id="decompy-matrix-factorization-adm-module"></span><h2>decompy.matrix_factorization.adm module<a class="headerlink" href="#module-decompy.matrix_factorization.adm" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.adm.AlternatingDirectionMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.adm.</span></span><span class="sig-name descname"><span class="pre">AlternatingDirectionMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.adm.AlternatingDirectionMethod" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Sparse and low-rank matrix decomposition using Alternating Direction Methods</p>
<p class="rubric">Notes</p>
<p>[1] Yuan, Xiaoming, and Junfeng Yang. “Sparse and low-rank matrix decomposition via alternating direction methods.” preprint 12.2 (2009).</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.adm.AlternatingDirectionMethod.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initLambda</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.adm.AlternatingDirectionMethod.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into a low-rank and sparse component using ADM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – The input matrix to decompose.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em>, </em><em>optional</em>) – Thresholding parameter. Default is 0.1.</p></li>
<li><p><strong>beta</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Regularization parameter. Default is 0.25 / abs(M).mean().</p></li>
<li><p><strong>initA</strong> (<em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Initial guess for the sparse component. Default is zeros.</p></li>
<li><p><strong>initB</strong> (<em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Initial guess for the low-rank component. Default is zeros.</p></li>
<li><p><strong>initLambda</strong> (<em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Initial guess for the Lagrange multiplier. Default is zeros.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the low-rank matrix L, sparse matrix S,
and convergence info.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.matrix_factorization.alm">
<span id="decompy-matrix-factorization-alm-module"></span><h2>decompy.matrix_factorization.alm module<a class="headerlink" href="#module-decompy.matrix_factorization.alm" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.alm.AugmentedLagrangianMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.alm.</span></span><span class="sig-name descname"><span class="pre">AugmentedLagrangianMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.alm.AugmentedLagrangianMethod" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust PCA using Augmented Lagrangian Method</p>
<p class="rubric">Notes</p>
<p>[1] Gongguo Tang and A. Nehorai, “Robust principal component analysis based on low-rank and block-sparse matrix decomposition,” 2011 45th Annual Conference on Information Sciences and Systems, Baltimore, MD, USA, 2011, pp. 1-5, doi: 10.1109/CISS.2011.5766144.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.alm.AugmentedLagrangianMethod.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.alm.AugmentedLagrangianMethod.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into low rank and sparse components using ALM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose</p></li>
<li><p><strong>rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Rank of the low rank component. If not provided,
will be estimated.</p></li>
<li><p><strong>kappa</strong> (<em>float</em><em>, </em><em>optional</em>) – ALM penalty parameter. Default is 1.1
if not provided.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em>, </em><em>optional</em>) – ALM penalty parameter. Default is 0.61
if not provided.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the low rank matrix L,
sparse matrix S, optional noise matrix N,
and convergence info.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.matrix_factorization.ealm">
<span id="decompy-matrix-factorization-ealm-module"></span><h2>decompy.matrix_factorization.ealm module<a class="headerlink" href="#module-decompy.matrix_factorization.ealm" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.ealm.ExactAugmentedLagrangianMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.ealm.</span></span><span class="sig-name descname"><span class="pre">ExactAugmentedLagrangianMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.ealm.ExactAugmentedLagrangianMethod" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust PCA using Exact Augmented Lagrangian Multiplier Method</p>
<p class="rubric">Notes</p>
<p>[1] Lin, Zhouchen, Minming Chen, and Yi Ma. “The augmented lagrange multiplier method for exact recovery of corrupted low-rank matrices.” arXiv preprint arXiv:1009.5055 (2010).</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.ealm.ExactAugmentedLagrangianMethod.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.ealm.ExactAugmentedLagrangianMethod.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into a low-rank matrix L and a sparse matrix S.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose</p></li>
<li><p><strong>lambd</strong> (<em>float</em><em>, </em><em>optional</em>) – Weight on sparse error term in cost function.
Default is 1/sqrt(m) where m is number of rows in M</p></li>
<li><p><strong>mu</strong> (<em>float</em><em>, </em><em>optional</em>) – Regularization parameter for low-rank matrix.
Default is 0.5 / norm_two where norm_two is L2 norm of M</p></li>
<li><p><strong>rho</strong> (<em>float</em><em>, </em><em>default 6</em>) – Parameter for increasing mu at each iteration</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Named tuple containing low-rank matrix L, sparse matrix S
and convergence info</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.matrix_factorization.fpcp">
<span id="decompy-matrix-factorization-fpcp-module"></span><h2>decompy.matrix_factorization.fpcp module<a class="headerlink" href="#module-decompy.matrix_factorization.fpcp" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.fpcp.FastPrincipalComponentPursuit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.fpcp.</span></span><span class="sig-name descname"><span class="pre">FastPrincipalComponentPursuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.fpcp.FastPrincipalComponentPursuit" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust PCA using Fast Principal Component Pursuit Method</p>
<p class="rubric">Notes</p>
<p>[1] P. Rodríguez and B. Wohlberg, “Fast principal component pursuit via alternating minimization,” 2013 IEEE International Conference on Image Processing, Melbourne, VIC, Australia, 2013, pp. 69-73, doi: 10.1109/ICIP.2013.6738015.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.fpcp.FastPrincipalComponentPursuit.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initrank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank_threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdaval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdafactor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.fpcp.FastPrincipalComponentPursuit.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M using FPCP method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – The input matrix to decompose.</p></li>
<li><p><strong>initrank</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The initial rank estimate. If None, set to 1.
Default is None.</p></li>
<li><p><strong>rank_threshold</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The threshold value for incrementing the rank.
If None, set to 0.01.
Default is None.</p></li>
<li><p><strong>lambdaval</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The regularization parameter. If None, set to 1/sqrt(max(n,p)).
Default is None.</p></li>
<li><p><strong>lambdafactor</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The factor to decrease lambda at each iteration.
If None, set to 1.
Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the final U, S, V^T matrices along
with convergence information.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.svdresult.SVDResult" title="decompy.interfaces.svdresult.SVDResult">SVDResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.matrix_factorization.ialm">
<span id="decompy-matrix-factorization-ialm-module"></span><h2>decompy.matrix_factorization.ialm module<a class="headerlink" href="#module-decompy.matrix_factorization.ialm" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.ialm.InexactAugmentedLagrangianMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.ialm.</span></span><span class="sig-name descname"><span class="pre">InexactAugmentedLagrangianMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.ialm.InexactAugmentedLagrangianMethod" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Inexact Augmented Lagrangian Method for Robust PCA</p>
<dl class="simple">
<dt>Reference: Augmented Lagrange multiplier method for Robust PCA - Inexact method</dt><dd><ul class="simple">
<li><p>Minming Chen, October 2009. Questions? <a class="reference external" href="mailto:v-minmch&#37;&#52;&#48;microsoft&#46;com">v-minmch<span>&#64;</span>microsoft<span>&#46;</span>com</a></p></li>
<li><p>Arvind Ganesh (<a class="reference external" href="mailto:abalasu2&#37;&#52;&#48;illinois&#46;edu">abalasu2<span>&#64;</span>illinois<span>&#46;</span>edu</a>)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.ialm.InexactAugmentedLagrangianMethod.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.ialm.InexactAugmentedLagrangianMethod.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into a low rank L and sparse S using Inexact ALM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose</p></li>
<li><p><strong>lambd</strong> (<em>float</em><em>, </em><em>optional</em>) – Weight on sparse error term in cost function.
Default is 1/sqrt(m) where m is number of rows in M</p></li>
<li><p><strong>mu</strong> (<em>float</em><em>, </em><em>optional</em>) – Initial penalty parameter.
Default is 1.25 / frobenius norm of M</p></li>
<li><p><strong>rho</strong> (<em>float</em><em>, </em><em>optional</em>) – Factor to increase mu by at each iteration.
Default is 1.5</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Named tuple containing low rank L, sparse S, and convergence info.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Inexact ALM algorithm decomposes M into L and S by
minimizing the objective:</p>
<blockquote>
<div><p>||L||_* + lambd||S||_1
s.t. M = L + S</p>
</div></blockquote>
<p>where ||.||_* is nuclear norm (sum of singular values) and
||.||_1 is L1 norm (sum of absolute values).</p>
</dd></dl>

</dd></dl>

</section>
<section id="decompy-matrix-factorization-mest-module">
<h2>decompy.matrix_factorization.mest module<a class="headerlink" href="#decompy-matrix-factorization-mest-module" title="Link to this heading">¶</a></h2>
</section>
<section id="module-decompy.matrix_factorization.op">
<span id="decompy-matrix-factorization-op-module"></span><h2>decompy.matrix_factorization.op module<a class="headerlink" href="#module-decompy.matrix_factorization.op" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.op.OutlierPursuit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.op.</span></span><span class="sig-name descname"><span class="pre">OutlierPursuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.op.OutlierPursuit" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Matrix completion algorithm via Outlier Pursuit</p>
<p class="rubric">Notes</p>
<p>[1] H. Xu, C. Caramanis and S. Sanghavi, “Robust PCA via Outlier Pursuit,” in IEEE Transactions on Information Theory, vol. 58, no. 5, pp. 3047-3064, May 2012, doi: 10.1109/TIT.2011.2173156.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.op.OutlierPursuit.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega_mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.op.OutlierPursuit.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into low rank matrices L and S.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – The input matrix to decompose.</p></li>
<li><p><strong>rank</strong> (<em>int</em><em>, </em><em>optional</em>) – The rank of the decomposition. If not provided, set to 10% of min(m, n).</p></li>
<li><p><strong>lambd</strong> (<em>float</em><em>, </em><em>optional</em>) – Regularization parameter for S. If not provided, set to 1/sqrt(min(m, n)).</p></li>
<li><p><strong>Omega_mask</strong> (<em>ndarray</em><em>, </em><em>optional</em>) – Binary mask indicating observed entries. 1 means observed.
If not provided, all entries are observed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the low rank factor L, sparse factor S
and convergence information.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.matrix_factorization.pcp">
<span id="decompy-matrix-factorization-pcp-module"></span><h2>decompy.matrix_factorization.pcp module<a class="headerlink" href="#module-decompy.matrix_factorization.pcp" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.pcp.PrincipalComponentPursuit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.pcp.</span></span><span class="sig-name descname"><span class="pre">PrincipalComponentPursuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.pcp.PrincipalComponentPursuit" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust PCA using Principal Component Pursuit Method</p>
<p class="rubric">Notes</p>
<p>[1] Candès, Emmanuel J., et al. “Robust principal component analysis?.” Journal of the ACM (JACM) 58.3 (2011): 1-37.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.pcp.PrincipalComponentPursuit.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdaval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">muval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.pcp.PrincipalComponentPursuit.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix into low-rank and sparse components using Principal Component Pursuit (PCP).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – The input matrix to decompose.</p></li>
<li><p><strong>lambdaval</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Regularization parameter for the nuclear norm. Default is 1/sqrt(max(n, p))
where n, p are dimensions of M.</p></li>
<li><p><strong>muval</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Regularization parameter for the l1 norm. Default is (n*p)/(4 * abs(X).sum())
where n, p are dimensions of M.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the low-rank component U, singular values s,
orthogonal matrix V and convergence metrics.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.svdresult.SVDResult" title="decompy.interfaces.svdresult.SVDResult">SVDResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.matrix_factorization.rsvddpd">
<span id="decompy-matrix-factorization-rsvddpd-module"></span><h2>decompy.matrix_factorization.rsvddpd module<a class="headerlink" href="#module-decompy.matrix_factorization.rsvddpd" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.rsvddpd.RobustSVDDensityPowerDivergence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.rsvddpd.</span></span><span class="sig-name descname"><span class="pre">RobustSVDDensityPowerDivergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.rsvddpd.RobustSVDDensityPowerDivergence" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust SVD using Density Power Divergence based Alternating Regression Method</p>
<p class="rubric">Notes</p>
<p>[1] Roy, Subhrajyoty, Ayanendranath Basu, and Abhik Ghosh. “A New Robust Scalable Singular Value Decomposition Algorithm for Video Surveillance Background Modelling.” arXiv preprint arXiv:2109.10680 (2021).</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.rsvddpd.RobustSVDDensityPowerDivergence.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initv</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.rsvddpd.RobustSVDDensityPowerDivergence.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into U, S, V using robust SVD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose, of shape (n, p).</p></li>
<li><p><strong>rank</strong> (<em>int</em>) – Rank of the decomposition.</p></li>
<li><p><strong>initu</strong> (<em>ndarray</em>) – Left singular vectors at initialization, of shape (n, rank). Leave blank if to be initialized by initialization method.</p></li>
<li><p><strong>initv</strong> (<em>ndarray</em>) – Right singular vectors at initialization, of shape (p, rank). Leave blank if to be initialized by initialization method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>res</strong> – A tuple containing the factorization results</p>
<dl class="simple">
<dt>sigs<span class="classifier">ndarray</span></dt><dd><p>Singular values, of shape (rank,).</p>
</dd>
<dt>U<span class="classifier">ndarray</span></dt><dd><p>Left singular vectors, of shape (n, rank).</p>
</dd>
<dt>V<span class="classifier">ndarray</span></dt><dd><p>Right singular vectors, of shape (p, rank).</p>
</dd>
<dt>niter<span class="classifier">int</span></dt><dd><p>Number of iterations taken.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.svdresult.SVDResult" title="decompy.interfaces.svdresult.SVDResult">SVDResult</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Implements the rSVD-DPD algorithm from <a href="#id25"><span class="problematic" id="id1">[1]_</span></a>.</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="20">
<li><p>Zhou and D. Tao, “GoDec: Randomized Low-rank &amp; Sparse Matrix Decomposition in Noisy Case”, ICML-11.</p></li>
</ol>
</aside>
</aside>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.rsvddpd.RobustSVDDensityPowerDivergence.sanity_check">
<span class="sig-name descname"><span class="pre">sanity_check</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxit_reached</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.rsvddpd.RobustSVDDensityPowerDivergence.sanity_check" title="Link to this definition">¶</a></dt>
<dd><p>Performs sanity checks on the output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>ndarray</em>) – The input data matrix</p></li>
<li><p><strong>lambdas</strong> (<em>ndarray</em>) – The computed singular values</p></li>
<li><p><strong>maxit_reached</strong> (<em>ndarray</em>) – Boolean array indicating if max iterations were reached</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Checks if max iterations were reached and warns if so.
Also checks if singular values are in decreasing order.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.matrix_factorization.svt">
<span id="decompy-matrix-factorization-svt-module"></span><h2>decompy.matrix_factorization.svt module<a class="headerlink" href="#module-decompy.matrix_factorization.svt" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.svt.SingularValueThresholding">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.svt.</span></span><span class="sig-name descname"><span class="pre">SingularValueThresholding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.svt.SingularValueThresholding" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Implements the Singular Value Thresholding (SVT) algorithm for
Robust PCA.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.svt.SingularValueThresholding.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdaval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.svt.SingularValueThresholding.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into low-rank (L) and sparse (S) components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose</p></li>
<li><p><strong>lambdaval</strong> (<em>float</em>) – Regularization parameter for sparse component</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Threshold for singular values, by default None</p></li>
<li><p><strong>delta</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Step size for dual ascent, by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Named tuple containing low-rank matrix L, sparse matrix S,
noise matrix N, and convergence info</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.matrix_factorization.vbrpca">
<span id="decompy-matrix-factorization-vbrpca-module"></span><h2>decompy.matrix_factorization.vbrpca module<a class="headerlink" href="#module-decompy.matrix_factorization.vbrpca" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.vbrpca.VariationalBayes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.vbrpca.</span></span><span class="sig-name descname"><span class="pre">VariationalBayes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.vbrpca.VariationalBayes" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust PCA using Variational Bayesian method</p>
<p class="rubric">Notes</p>
<p>[1] S. D. Babacan, M. Luessi, R. Molina and A. K. Katsaggelos, “Sparse Bayesian Methods for Low-Rank Matrix Estimation,” in IEEE Transactions on Signal Processing, vol. 60, no. 8, pp. 3964-3977, Aug. 2012, doi: 10.1109/TSP.2012.2197748.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.vbrpca.VariationalBayes.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.vbrpca.VariationalBayes.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into low rank and sparse components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose, of shape (m, n)</p></li>
<li><p><strong>rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Rank of the low rank component. If not provided, the minimum of m and n
is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>ndarray</em>) – Low rank component, of shape (m, rank)</p></li>
<li><p><strong>B</strong> (<em>ndarray</em>) – Low rank component, of shape (rank, n)</p></li>
<li><p><strong>E</strong> (<em>ndarray</em>) – Sparse component, of shape (m, n)</p></li>
<li><p><strong>X</strong> (<em>ndarray</em>) – Reconstructed low rank component <a class="reference external" href="mailto:A&#37;&#52;&#48;B&#46;T">A<span>&#64;</span>B<span>&#46;</span>T</a>, of shape (m, n)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-decompy.matrix_factorization">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-decompy.matrix_factorization" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.ActiveSubspaceRobustPCA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">ActiveSubspaceRobustPCA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.ActiveSubspaceRobustPCA" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>AS-RPCA: Active Subspace: Towards Scalable Low-Rank Learning</p>
<p class="rubric">Notes</p>
<p>[1] Guangcan Liu and Shuicheng Yan. 2012. Active subspace: Toward scalable low-rank learning. Neural Comput. 24, 12 (December 2012), 3371-3394. <a class="reference external" href="https://doi.org/10.1162/NECO_a_00369">https://doi.org/10.1162/NECO_a_00369</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.ActiveSubspaceRobustPCA.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.ActiveSubspaceRobustPCA.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix into low rank and sparse components.</p>
<p>Decomposes the input matrix <cite>M</cite> into the sum of
a low-rank matrix <cite>L</cite> and a sparse matrix <cite>S</cite>,
by solving the optimization problem:</p>
<p>min <a href="#id3"><span class="problematic" id="id4">|</span></a>L|_* + lambda <a href="#id5"><span class="problematic" id="id6">|</span></a>S|_1
s.t. M = L + S</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose</p></li>
<li><p><strong>k</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Rank of the low-rank component.
If None, default is max(1, round(min(M.shape)/10))</p></li>
<li><p><strong>lambd</strong> (<em>float</em><em>, </em><em>optional</em>) – Regularization parameter for the sparsity term.
If None, default is 1/sqrt(min(M.shape))</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Named tuple containing:</p>
<p>L : Low-rank component</p>
<p>S : Sparse component</p>
<p>N : Null component (all zeros)</p>
<dl class="simple">
<dt>convergence<span class="classifier">Dictionary with keys:</span></dt><dd><p>’niter’ : Number of iterations
‘converged’ : Whether converged within max iterations
‘final_error’ : Final reconstruction error</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.AlternatingDirectionMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">AlternatingDirectionMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.AlternatingDirectionMethod" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Sparse and low-rank matrix decomposition using Alternating Direction Methods</p>
<p class="rubric">Notes</p>
<p>[1] Yuan, Xiaoming, and Junfeng Yang. “Sparse and low-rank matrix decomposition via alternating direction methods.” preprint 12.2 (2009).</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.AlternatingDirectionMethod.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initLambda</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.AlternatingDirectionMethod.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into a low-rank and sparse component using ADM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – The input matrix to decompose.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em>, </em><em>optional</em>) – Thresholding parameter. Default is 0.1.</p></li>
<li><p><strong>beta</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Regularization parameter. Default is 0.25 / abs(M).mean().</p></li>
<li><p><strong>initA</strong> (<em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Initial guess for the sparse component. Default is zeros.</p></li>
<li><p><strong>initB</strong> (<em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Initial guess for the low-rank component. Default is zeros.</p></li>
<li><p><strong>initLambda</strong> (<em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Initial guess for the Lagrange multiplier. Default is zeros.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the low-rank matrix L, sparse matrix S,
and convergence info.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.AugmentedLagrangianMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">AugmentedLagrangianMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.AugmentedLagrangianMethod" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust PCA using Augmented Lagrangian Method</p>
<p class="rubric">Notes</p>
<p>[1] Gongguo Tang and A. Nehorai, “Robust principal component analysis based on low-rank and block-sparse matrix decomposition,” 2011 45th Annual Conference on Information Sciences and Systems, Baltimore, MD, USA, 2011, pp. 1-5, doi: 10.1109/CISS.2011.5766144.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.AugmentedLagrangianMethod.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.AugmentedLagrangianMethod.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into low rank and sparse components using ALM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose</p></li>
<li><p><strong>rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Rank of the low rank component. If not provided,
will be estimated.</p></li>
<li><p><strong>kappa</strong> (<em>float</em><em>, </em><em>optional</em>) – ALM penalty parameter. Default is 1.1
if not provided.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em>, </em><em>optional</em>) – ALM penalty parameter. Default is 0.61
if not provided.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the low rank matrix L,
sparse matrix S, optional noise matrix N,
and convergence info.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.DualRobustPCA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">DualRobustPCA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.DualRobustPCA" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This solves the robust PCA problem using dual formalization</p>
<dl class="simple">
<dt>The Primal Robust PCA relaxation</dt><dd><p>min tau ( <a href="#id7"><span class="problematic" id="id8">|</span></a>A|_* + lambda <a href="#id9"><span class="problematic" id="id10">|</span></a>E|_1 ) + 1/2 <a href="#id11"><span class="problematic" id="id12">|</span></a>(A,E)|_F^2
subj  A+E = D</p>
</dd>
<dt>The Dual problem</dt><dd><p>max trace(D’ * Y)
subj max( <a href="#id13"><span class="problematic" id="id14">|</span></a>Y|_2,1 + lambda <a href="#id15"><span class="problematic" id="id16">|</span></a>Y|_inf) &lt;= 1</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>[1] Robust PCA: Exact Recovery of Corrupted Low-Rank Matrices via Convex Optimization”, J. Wright et al., preprint 2009.
[2] “Fast Convex Optimization Algorithms for Exact Recovery of a Corrupted Low-Rank Matrix”, Z. Lin et al.,  preprint 2009.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.DualRobustPCA.choosvd">
<span class="sig-name descname"><span class="pre">choosvd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.DualRobustPCA.choosvd" title="Link to this definition">¶</a></dt>
<dd><p>Choose whether to use SVD based on matrix dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – Number of rows/columns in the matrix.</p></li>
<li><p><strong>d</strong> (<em>int</em>) – Rank of the matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if SVD should be used based on the ratio of d to n, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.DualRobustPCA.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.DualRobustPCA.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into two low-rank matrices using dual proximal gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – The input matrix to decompose.</p></li>
<li><p><strong>lambd</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Regularization parameter. Default is 1/sqrt(m) where m is the number of rows of M.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the low rank matrix L,
sparse matrix S, optional noise matrix N,
and convergence info.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.ExactAugmentedLagrangianMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">ExactAugmentedLagrangianMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.ExactAugmentedLagrangianMethod" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust PCA using Exact Augmented Lagrangian Multiplier Method</p>
<p class="rubric">Notes</p>
<p>[1] Lin, Zhouchen, Minming Chen, and Yi Ma. “The augmented lagrange multiplier method for exact recovery of corrupted low-rank matrices.” arXiv preprint arXiv:1009.5055 (2010).</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.ExactAugmentedLagrangianMethod.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.ExactAugmentedLagrangianMethod.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into a low-rank matrix L and a sparse matrix S.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose</p></li>
<li><p><strong>lambd</strong> (<em>float</em><em>, </em><em>optional</em>) – Weight on sparse error term in cost function.
Default is 1/sqrt(m) where m is number of rows in M</p></li>
<li><p><strong>mu</strong> (<em>float</em><em>, </em><em>optional</em>) – Regularization parameter for low-rank matrix.
Default is 0.5 / norm_two where norm_two is L2 norm of M</p></li>
<li><p><strong>rho</strong> (<em>float</em><em>, </em><em>default 6</em>) – Parameter for increasing mu at each iteration</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Named tuple containing low-rank matrix L, sparse matrix S
and convergence info</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.FastPrincipalComponentPursuit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">FastPrincipalComponentPursuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.FastPrincipalComponentPursuit" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust PCA using Fast Principal Component Pursuit Method</p>
<p class="rubric">Notes</p>
<p>[1] P. Rodríguez and B. Wohlberg, “Fast principal component pursuit via alternating minimization,” 2013 IEEE International Conference on Image Processing, Melbourne, VIC, Australia, 2013, pp. 69-73, doi: 10.1109/ICIP.2013.6738015.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.FastPrincipalComponentPursuit.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initrank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank_threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdaval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdafactor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.FastPrincipalComponentPursuit.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M using FPCP method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – The input matrix to decompose.</p></li>
<li><p><strong>initrank</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The initial rank estimate. If None, set to 1.
Default is None.</p></li>
<li><p><strong>rank_threshold</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The threshold value for incrementing the rank.
If None, set to 0.01.
Default is None.</p></li>
<li><p><strong>lambdaval</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The regularization parameter. If None, set to 1/sqrt(max(n,p)).
Default is None.</p></li>
<li><p><strong>lambdafactor</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The factor to decrease lambda at each iteration.
If None, set to 1.
Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the final U, S, V^T matrices along
with convergence information.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.svdresult.SVDResult" title="decompy.interfaces.svdresult.SVDResult">SVDResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.GrassmannAverage">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">GrassmannAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.GrassmannAverage" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>GRASSMANN_AVERAGE(X) returns a basis vector for the average one-dimensional
subspace spanned by the data X. This is a N-by-D matrix containing N observations
in R^D.</p>
<p>GRASSMANN_AVERAGE(X, K) returns a D-by-K matrix of orthogonal basis vectors
spanning a K-dimensional average subspace.</p>
<p class="rubric">References</p>
<p>[1] “Grassmann Averages for Scalable Robust PCA”.  S. Hauberg, A. Feragen and M.J. Black. In CVPR 2014. <a class="reference external" href="http://ps.is.tue.mpg.de/project/Robust_PCA">http://ps.is.tue.mpg.de/project/Robust_PCA</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.GrassmannAverage.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.GrassmannAverage.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into two low rank matrices using Grassmann averages.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – The input matrix to decompose, of shape (N, D).</p></li>
<li><p><strong>K</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The target rank for decomposition. If not provided, default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>res</strong> – A named tuple containing the low rank factors A and B, as well as
convergence diagnostics.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.rankfactorresult.RankFactorizationResult" title="decompy.interfaces.rankfactorresult.RankFactorizationResult">RankFactorizationResult</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The algorithm is based on Grassmann averages. It iteratively extracts
the top K principal components while orthogonalizing them.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decompy.matrix_factorization</span> <span class="kn">import</span> <span class="n">GrassmannAverage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ga</span> <span class="o">=</span> <span class="n">GrassmannAverage</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ga</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">B</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.InexactAugmentedLagrangianMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">InexactAugmentedLagrangianMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.InexactAugmentedLagrangianMethod" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Inexact Augmented Lagrangian Method for Robust PCA</p>
<dl class="simple">
<dt>Reference: Augmented Lagrange multiplier method for Robust PCA - Inexact method</dt><dd><ul class="simple">
<li><p>Minming Chen, October 2009. Questions? <a class="reference external" href="mailto:v-minmch&#37;&#52;&#48;microsoft&#46;com">v-minmch<span>&#64;</span>microsoft<span>&#46;</span>com</a></p></li>
<li><p>Arvind Ganesh (<a class="reference external" href="mailto:abalasu2&#37;&#52;&#48;illinois&#46;edu">abalasu2<span>&#64;</span>illinois<span>&#46;</span>edu</a>)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.InexactAugmentedLagrangianMethod.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.InexactAugmentedLagrangianMethod.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into a low rank L and sparse S using Inexact ALM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose</p></li>
<li><p><strong>lambd</strong> (<em>float</em><em>, </em><em>optional</em>) – Weight on sparse error term in cost function.
Default is 1/sqrt(m) where m is number of rows in M</p></li>
<li><p><strong>mu</strong> (<em>float</em><em>, </em><em>optional</em>) – Initial penalty parameter.
Default is 1.25 / frobenius norm of M</p></li>
<li><p><strong>rho</strong> (<em>float</em><em>, </em><em>optional</em>) – Factor to increase mu by at each iteration.
Default is 1.5</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Named tuple containing low rank L, sparse S, and convergence info.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Inexact ALM algorithm decomposes M into L and S by
minimizing the objective:</p>
<blockquote>
<div><p>||L||_* + lambd||S||_1
s.t. M = L + S</p>
</div></blockquote>
<p>where ||.||_* is nuclear norm (sum of singular values) and
||.||_1 is L1 norm (sum of absolute values).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.L1Filtering">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">L1Filtering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.L1Filtering" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust PCA using L1 Filtering</p>
<p class="rubric">Notes</p>
<p>[1] Liu, R., Lin, Z., Wei, S., &amp; Su, Z. (2011). Solving principal component pursuit in linear time via $ l_1 $ filtering. arXiv preprint arXiv:1108.5359.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.L1Filtering.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.L1Filtering.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into low-rank, sparse and noise components using L1 factorization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose.</p></li>
<li><p><strong>sr</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of rows to sample for initialization. Default is 1.</p></li>
<li><p><strong>sc</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of columns to sample for initialization. Default is same as sr.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A named tuple containing the low-rank, sparse and noise components.
L : ndarray</p>
<blockquote>
<div><p>Low-rank component</p>
</div></blockquote>
<dl class="simple">
<dt>S<span class="classifier">ndarray</span></dt><dd><p>Sparse component</p>
</dd>
<dt>N<span class="classifier">ndarray</span></dt><dd><p>Noise component (zeros)</p>
</dd>
<dt>convergence<span class="classifier">dict</span></dt><dd><dl class="simple">
<dt>Dictionary containing convergence info with keys:</dt><dd><p>’iteration’: number of iterations
‘converged’: boolean indicating if converged
‘error’: final error value</p>
</dd>
</dl>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.LinearizedADMAdaptivePenalty">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">LinearizedADMAdaptivePenalty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.LinearizedADMAdaptivePenalty" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Linearized Alternating Direction Method with Adaptive Penalty</p>
<p>It aims to solve the LRR problem
min <a href="#id17"><span class="problematic" id="id18">|</span></a>Z|_*+lambda*|E|_2,1  s.t., X = XZ+E, where lambda is a penalty parameter.</p>
<p class="rubric">Notes</p>
<p>[1] Linearized Alternating Direction Method with Adaptive Penalty for Low-Rank Representation, Lin et al., 2011 - <a class="reference external" href="http://arxiv.org/abs/1109.0367">http://arxiv.org/abs/1109.0367</a>
[2] Original MATLAB code created by Risheng Liu on 05/02/2011, <a class="reference external" href="mailto:rsliu0705&#37;&#52;&#48;gmail&#46;com">rsliu0705<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.LinearizedADMAdaptivePenalty.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.LinearizedADMAdaptivePenalty.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into low-rank (L), sparse (S) and noise (N) components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – The input matrix to decompose.</p></li>
<li><p><strong>rho</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The multiplicative factor to increase mu at each iteration. Default is 1.9.</p></li>
<li><p><strong>lambd</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The regularization parameter for the L1 norm of S. Default is 0.1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the low-rank matrix L, sparse matrix S,
noise matrix N and convergence details.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.MixtureOfGaussianRobustPCA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">MixtureOfGaussianRobustPCA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.MixtureOfGaussianRobustPCA" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Original Author:
Written by Qian Zhao (if you have any questions/comments/suggestions, please contact me: <a class="reference external" href="mailto:timmy&#46;zhaoqian&#37;&#52;&#48;gmail&#46;com">timmy<span>&#46;</span>zhaoqian<span>&#64;</span>gmail<span>&#46;</span>com</a>)</p>
<p class="rubric">References</p>
<p>[1] “Qian Zhao, Deyu Meng, Zongben Xu, Wangmeng Zuo, Lei Zhang. Robust Principal Component Analysis with Complex Noise. ICML, 2014.”</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.MixtureOfGaussianRobustPCA.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_prior</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">LRPrior</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mog_prior</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">MOGPrior</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.MixtureOfGaussianRobustPCA.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into low rank (L) and sparse noise (S) components using MOG prior.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose</p></li>
<li><p><strong>rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Rank of the low rank component. If not specified, set to min(m, n)</p></li>
<li><p><strong>lr_prior</strong> (<em>LRPrior</em><em>, </em><em>optional</em>) – Prior for low rank component</p></li>
<li><p><strong>mog_prior</strong> (<em>MOGPrior</em><em>, </em><em>optional</em>) – Prior for sparse noise component</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – Result object containing:
- L : Low rank component
- S : Sparse noise component
- N : None (not used)
- convergence : Dictionary with convergence details
- lr_model : Low rank model parameters
- mog_model : Sparse noise model parameters</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.OutlierPursuit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">OutlierPursuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.OutlierPursuit" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Matrix completion algorithm via Outlier Pursuit</p>
<p class="rubric">Notes</p>
<p>[1] H. Xu, C. Caramanis and S. Sanghavi, “Robust PCA via Outlier Pursuit,” in IEEE Transactions on Information Theory, vol. 58, no. 5, pp. 3047-3064, May 2012, doi: 10.1109/TIT.2011.2173156.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.OutlierPursuit.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega_mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.OutlierPursuit.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into low rank matrices L and S.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – The input matrix to decompose.</p></li>
<li><p><strong>rank</strong> (<em>int</em><em>, </em><em>optional</em>) – The rank of the decomposition. If not provided, set to 10% of min(m, n).</p></li>
<li><p><strong>lambd</strong> (<em>float</em><em>, </em><em>optional</em>) – Regularization parameter for S. If not provided, set to 1/sqrt(min(m, n)).</p></li>
<li><p><strong>Omega_mask</strong> (<em>ndarray</em><em>, </em><em>optional</em>) – Binary mask indicating observed entries. 1 means observed.
If not provided, all entries are observed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the low rank factor L, sparse factor S
and convergence information.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.PrincipalComponentPursuit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">PrincipalComponentPursuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.PrincipalComponentPursuit" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust PCA using Principal Component Pursuit Method</p>
<p class="rubric">Notes</p>
<p>[1] Candès, Emmanuel J., et al. “Robust principal component analysis?.” Journal of the ACM (JACM) 58.3 (2011): 1-37.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.PrincipalComponentPursuit.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdaval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">muval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.PrincipalComponentPursuit.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix into low-rank and sparse components using Principal Component Pursuit (PCP).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – The input matrix to decompose.</p></li>
<li><p><strong>lambdaval</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Regularization parameter for the nuclear norm. Default is 1/sqrt(max(n, p))
where n, p are dimensions of M.</p></li>
<li><p><strong>muval</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Regularization parameter for the l1 norm. Default is (n*p)/(4 * abs(X).sum())
where n, p are dimensions of M.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the low-rank component U, singular values s,
orthogonal matrix V and convergence metrics.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.svdresult.SVDResult" title="decompy.interfaces.svdresult.SVDResult">SVDResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.RegulaizedL1AugmentedLagrangianMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">RegulaizedL1AugmentedLagrangianMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.RegulaizedL1AugmentedLagrangianMethod" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Implements the Regularized L1 Augmented Lagrangian algorithm for low rank matrix factorization
with trace norm regularization.</p>
<dl class="simple">
<dt>Robust low-rank matrix approximation with missing data and outliers</dt><dd><p>min <a href="#id19"><span class="problematic" id="id20">|</span></a>W.*(M-E)|_1 + lambda*|V|_*
s.t., E = UV, U’<a href="#id21"><span class="problematic" id="id22">*</span></a>U = I</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>[1] Y. Zheng, G. Liu, S. Sugimoto, S. Yan and M. Okutomi, “Practical low-rank matrix approximation under robust L1-norm,” 2012 IEEE Conference on Computer Vision and Pattern Recognition, Providence, RI, USA, 2012, pp. 1410-1417, doi: 10.1109/CVPR.2012.6247828. keywords: {Robustness;Optimization;Convergence;Computer vision;Approximation algorithms;Least squares approximation},</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.RegulaizedL1AugmentedLagrangianMethod.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.RegulaizedL1AugmentedLagrangianMethod.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix D into low rank factors U and V.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>D</strong> (<em>ndarray</em>) – The m x n data matrix to decompose.</p></li>
<li><p><strong>W</strong> (<em>ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The m x n indicator matrix, with 1 representing observed entries
and 0 representing missing entries. Default is None, which means
all entries are observed.</p></li>
<li><p><strong>r</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The rank of the decomposition. If None, default is ceil(0.1*min(m,n)).</p></li>
<li><p><strong>lambd</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The regularization parameter. Default is 1e-3.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>res</strong> – A named tuple containing the low rank factors U and V, and convergence
info such as number of iterations, error, etc.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.rankfactorresult.RankFactorizationResult" title="decompy.interfaces.rankfactorresult.RankFactorizationResult">RankFactorizationResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.RobustSVDDensityPowerDivergence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">RobustSVDDensityPowerDivergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.RobustSVDDensityPowerDivergence" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust SVD using Density Power Divergence based Alternating Regression Method</p>
<p class="rubric">Notes</p>
<p>[1] Roy, Subhrajyoty, Ayanendranath Basu, and Abhik Ghosh. “A New Robust Scalable Singular Value Decomposition Algorithm for Video Surveillance Background Modelling.” arXiv preprint arXiv:2109.10680 (2021).</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.RobustSVDDensityPowerDivergence.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initv</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.RobustSVDDensityPowerDivergence.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into U, S, V using robust SVD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose, of shape (n, p).</p></li>
<li><p><strong>rank</strong> (<em>int</em>) – Rank of the decomposition.</p></li>
<li><p><strong>initu</strong> (<em>ndarray</em>) – Left singular vectors at initialization, of shape (n, rank). Leave blank if to be initialized by initialization method.</p></li>
<li><p><strong>initv</strong> (<em>ndarray</em>) – Right singular vectors at initialization, of shape (p, rank). Leave blank if to be initialized by initialization method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>res</strong> – A tuple containing the factorization results</p>
<dl class="simple">
<dt>sigs<span class="classifier">ndarray</span></dt><dd><p>Singular values, of shape (rank,).</p>
</dd>
<dt>U<span class="classifier">ndarray</span></dt><dd><p>Left singular vectors, of shape (n, rank).</p>
</dd>
<dt>V<span class="classifier">ndarray</span></dt><dd><p>Right singular vectors, of shape (p, rank).</p>
</dd>
<dt>niter<span class="classifier">int</span></dt><dd><p>Number of iterations taken.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.svdresult.SVDResult" title="decompy.interfaces.svdresult.SVDResult">SVDResult</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Implements the rSVD-DPD algorithm from <a href="#id26"><span class="problematic" id="id23">[1]_</span></a>.</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id24" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="20">
<li><p>Zhou and D. Tao, “GoDec: Randomized Low-rank &amp; Sparse Matrix Decomposition in Noisy Case”, ICML-11.</p></li>
</ol>
</aside>
</aside>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.RobustSVDDensityPowerDivergence.sanity_check">
<span class="sig-name descname"><span class="pre">sanity_check</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxit_reached</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.RobustSVDDensityPowerDivergence.sanity_check" title="Link to this definition">¶</a></dt>
<dd><p>Performs sanity checks on the output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>ndarray</em>) – The input data matrix</p></li>
<li><p><strong>lambdas</strong> (<em>ndarray</em>) – The computed singular values</p></li>
<li><p><strong>maxit_reached</strong> (<em>ndarray</em>) – Boolean array indicating if max iterations were reached</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Checks if max iterations were reached and warns if so.
Also checks if singular values are in decreasing order.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.SingularValueThresholding">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">SingularValueThresholding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.SingularValueThresholding" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Implements the Singular Value Thresholding (SVT) algorithm for
Robust PCA.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.SingularValueThresholding.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdaval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.SingularValueThresholding.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into low-rank (L) and sparse (S) components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose</p></li>
<li><p><strong>lambdaval</strong> (<em>float</em>) – Regularization parameter for sparse component</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Threshold for singular values, by default None</p></li>
<li><p><strong>delta</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Step size for dual ascent, by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Named tuple containing low-rank matrix L, sparse matrix S,
noise matrix N, and convergence info</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.SymmetricAlternatingDirectionALM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">SymmetricAlternatingDirectionALM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.SymmetricAlternatingDirectionALM" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This is a symmetric version of the Alternating Direction Method of Multipliers (ADMM)</p>
<p class="rubric">Notes</p>
<p>[1] ‘’Fast Alternating Linearization Methods for Minimizing the Sum of Two Convex Functions’’, Donald Goldfarb, Shiqian Ma and Katya Scheinberg, Tech. Report, Columbia University, 2009 - 2010.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.SymmetricAlternatingDirectionALM.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sv</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.SymmetricAlternatingDirectionALM.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into low-rank (L), sparse (S) and noise (N) components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – The input matrix to decompose.</p></li>
<li><p><strong>sv</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The number of singular values to use in the decomposition. If None,
set to 10% of min(m, n) + 1.</p></li>
<li><p><strong>mu</strong> (<em>float</em><em>, </em><em>optional</em>) – Augmented Lagrangian parameter. Default is norm(M)/1.25.</p></li>
<li><p><strong>rho</strong> (<em>float</em><em>, </em><em>optional</em>) – Proximal parameter for the sparse component. Default is 1/sqrt(n).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple containing the low-rank (L), sparse (S) and noise (N)
components of the decomposition, and convergence information.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="decompy.interfaces.html#decompy.interfaces.lsnresult.LSNResult" title="decompy.interfaces.lsnresult.LSNResult">LSNResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decompy.matrix_factorization.VariationalBayes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decompy.matrix_factorization.</span></span><span class="sig-name descname"><span class="pre">VariationalBayes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.VariationalBayes" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Robust PCA using Variational Bayesian method</p>
<p class="rubric">Notes</p>
<p>[1] S. D. Babacan, M. Luessi, R. Molina and A. K. Katsaggelos, “Sparse Bayesian Methods for Low-Rank Matrix Estimation,” in IEEE Transactions on Signal Processing, vol. 60, no. 8, pp. 3964-3977, Aug. 2012, doi: 10.1109/TSP.2012.2197748.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decompy.matrix_factorization.VariationalBayes.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decompy.matrix_factorization.VariationalBayes.decompose" title="Link to this definition">¶</a></dt>
<dd><p>Decompose a matrix M into low rank and sparse components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – Input matrix to decompose, of shape (m, n)</p></li>
<li><p><strong>rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Rank of the low rank component. If not provided, the minimum of m and n
is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>ndarray</em>) – Low rank component, of shape (m, rank)</p></li>
<li><p><strong>B</strong> (<em>ndarray</em>) – Low rank component, of shape (rank, n)</p></li>
<li><p><strong>E</strong> (<em>ndarray</em>) – Sparse component, of shape (m, n)</p></li>
<li><p><strong>X</strong> (<em>ndarray</em>) – Reconstructed low rank component <a class="reference external" href="mailto:A&#37;&#52;&#48;B&#46;T">A<span>&#64;</span>B<span>&#46;</span>T</a>, of shape (m, n)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">decompy.matrix_factorization package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-decompy.matrix_factorization.adm">decompy.matrix_factorization.adm module</a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.adm.AlternatingDirectionMethod"><code class="docutils literal notranslate"><span class="pre">AlternatingDirectionMethod</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.adm.AlternatingDirectionMethod.decompose"><code class="docutils literal notranslate"><span class="pre">AlternatingDirectionMethod.decompose()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.matrix_factorization.alm">decompy.matrix_factorization.alm module</a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.alm.AugmentedLagrangianMethod"><code class="docutils literal notranslate"><span class="pre">AugmentedLagrangianMethod</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.alm.AugmentedLagrangianMethod.decompose"><code class="docutils literal notranslate"><span class="pre">AugmentedLagrangianMethod.decompose()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.matrix_factorization.ealm">decompy.matrix_factorization.ealm module</a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.ealm.ExactAugmentedLagrangianMethod"><code class="docutils literal notranslate"><span class="pre">ExactAugmentedLagrangianMethod</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.ealm.ExactAugmentedLagrangianMethod.decompose"><code class="docutils literal notranslate"><span class="pre">ExactAugmentedLagrangianMethod.decompose()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.matrix_factorization.fpcp">decompy.matrix_factorization.fpcp module</a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.fpcp.FastPrincipalComponentPursuit"><code class="docutils literal notranslate"><span class="pre">FastPrincipalComponentPursuit</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.fpcp.FastPrincipalComponentPursuit.decompose"><code class="docutils literal notranslate"><span class="pre">FastPrincipalComponentPursuit.decompose()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.matrix_factorization.ialm">decompy.matrix_factorization.ialm module</a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.ialm.InexactAugmentedLagrangianMethod"><code class="docutils literal notranslate"><span class="pre">InexactAugmentedLagrangianMethod</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.ialm.InexactAugmentedLagrangianMethod.decompose"><code class="docutils literal notranslate"><span class="pre">InexactAugmentedLagrangianMethod.decompose()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#decompy-matrix-factorization-mest-module">decompy.matrix_factorization.mest module</a></li>
<li><a class="reference internal" href="#module-decompy.matrix_factorization.op">decompy.matrix_factorization.op module</a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.op.OutlierPursuit"><code class="docutils literal notranslate"><span class="pre">OutlierPursuit</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.op.OutlierPursuit.decompose"><code class="docutils literal notranslate"><span class="pre">OutlierPursuit.decompose()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.matrix_factorization.pcp">decompy.matrix_factorization.pcp module</a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.pcp.PrincipalComponentPursuit"><code class="docutils literal notranslate"><span class="pre">PrincipalComponentPursuit</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.pcp.PrincipalComponentPursuit.decompose"><code class="docutils literal notranslate"><span class="pre">PrincipalComponentPursuit.decompose()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.matrix_factorization.rsvddpd">decompy.matrix_factorization.rsvddpd module</a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.rsvddpd.RobustSVDDensityPowerDivergence"><code class="docutils literal notranslate"><span class="pre">RobustSVDDensityPowerDivergence</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.rsvddpd.RobustSVDDensityPowerDivergence.decompose"><code class="docutils literal notranslate"><span class="pre">RobustSVDDensityPowerDivergence.decompose()</span></code></a></li>
<li><a class="reference internal" href="#decompy.matrix_factorization.rsvddpd.RobustSVDDensityPowerDivergence.sanity_check"><code class="docutils literal notranslate"><span class="pre">RobustSVDDensityPowerDivergence.sanity_check()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.matrix_factorization.svt">decompy.matrix_factorization.svt module</a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.svt.SingularValueThresholding"><code class="docutils literal notranslate"><span class="pre">SingularValueThresholding</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.svt.SingularValueThresholding.decompose"><code class="docutils literal notranslate"><span class="pre">SingularValueThresholding.decompose()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.matrix_factorization.vbrpca">decompy.matrix_factorization.vbrpca module</a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.vbrpca.VariationalBayes"><code class="docutils literal notranslate"><span class="pre">VariationalBayes</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.vbrpca.VariationalBayes.decompose"><code class="docutils literal notranslate"><span class="pre">VariationalBayes.decompose()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-decompy.matrix_factorization">Module contents</a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.ActiveSubspaceRobustPCA"><code class="docutils literal notranslate"><span class="pre">ActiveSubspaceRobustPCA</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.ActiveSubspaceRobustPCA.decompose"><code class="docutils literal notranslate"><span class="pre">ActiveSubspaceRobustPCA.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.AlternatingDirectionMethod"><code class="docutils literal notranslate"><span class="pre">AlternatingDirectionMethod</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.AlternatingDirectionMethod.decompose"><code class="docutils literal notranslate"><span class="pre">AlternatingDirectionMethod.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.AugmentedLagrangianMethod"><code class="docutils literal notranslate"><span class="pre">AugmentedLagrangianMethod</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.AugmentedLagrangianMethod.decompose"><code class="docutils literal notranslate"><span class="pre">AugmentedLagrangianMethod.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.DualRobustPCA"><code class="docutils literal notranslate"><span class="pre">DualRobustPCA</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.DualRobustPCA.choosvd"><code class="docutils literal notranslate"><span class="pre">DualRobustPCA.choosvd()</span></code></a></li>
<li><a class="reference internal" href="#decompy.matrix_factorization.DualRobustPCA.decompose"><code class="docutils literal notranslate"><span class="pre">DualRobustPCA.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.ExactAugmentedLagrangianMethod"><code class="docutils literal notranslate"><span class="pre">ExactAugmentedLagrangianMethod</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.ExactAugmentedLagrangianMethod.decompose"><code class="docutils literal notranslate"><span class="pre">ExactAugmentedLagrangianMethod.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.FastPrincipalComponentPursuit"><code class="docutils literal notranslate"><span class="pre">FastPrincipalComponentPursuit</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.FastPrincipalComponentPursuit.decompose"><code class="docutils literal notranslate"><span class="pre">FastPrincipalComponentPursuit.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.GrassmannAverage"><code class="docutils literal notranslate"><span class="pre">GrassmannAverage</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.GrassmannAverage.decompose"><code class="docutils literal notranslate"><span class="pre">GrassmannAverage.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.InexactAugmentedLagrangianMethod"><code class="docutils literal notranslate"><span class="pre">InexactAugmentedLagrangianMethod</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.InexactAugmentedLagrangianMethod.decompose"><code class="docutils literal notranslate"><span class="pre">InexactAugmentedLagrangianMethod.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.L1Filtering"><code class="docutils literal notranslate"><span class="pre">L1Filtering</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.L1Filtering.decompose"><code class="docutils literal notranslate"><span class="pre">L1Filtering.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.LinearizedADMAdaptivePenalty"><code class="docutils literal notranslate"><span class="pre">LinearizedADMAdaptivePenalty</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.LinearizedADMAdaptivePenalty.decompose"><code class="docutils literal notranslate"><span class="pre">LinearizedADMAdaptivePenalty.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.MixtureOfGaussianRobustPCA"><code class="docutils literal notranslate"><span class="pre">MixtureOfGaussianRobustPCA</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.MixtureOfGaussianRobustPCA.decompose"><code class="docutils literal notranslate"><span class="pre">MixtureOfGaussianRobustPCA.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.OutlierPursuit"><code class="docutils literal notranslate"><span class="pre">OutlierPursuit</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.OutlierPursuit.decompose"><code class="docutils literal notranslate"><span class="pre">OutlierPursuit.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.PrincipalComponentPursuit"><code class="docutils literal notranslate"><span class="pre">PrincipalComponentPursuit</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.PrincipalComponentPursuit.decompose"><code class="docutils literal notranslate"><span class="pre">PrincipalComponentPursuit.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.RegulaizedL1AugmentedLagrangianMethod"><code class="docutils literal notranslate"><span class="pre">RegulaizedL1AugmentedLagrangianMethod</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.RegulaizedL1AugmentedLagrangianMethod.decompose"><code class="docutils literal notranslate"><span class="pre">RegulaizedL1AugmentedLagrangianMethod.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.RobustSVDDensityPowerDivergence"><code class="docutils literal notranslate"><span class="pre">RobustSVDDensityPowerDivergence</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.RobustSVDDensityPowerDivergence.decompose"><code class="docutils literal notranslate"><span class="pre">RobustSVDDensityPowerDivergence.decompose()</span></code></a></li>
<li><a class="reference internal" href="#decompy.matrix_factorization.RobustSVDDensityPowerDivergence.sanity_check"><code class="docutils literal notranslate"><span class="pre">RobustSVDDensityPowerDivergence.sanity_check()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.SingularValueThresholding"><code class="docutils literal notranslate"><span class="pre">SingularValueThresholding</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.SingularValueThresholding.decompose"><code class="docutils literal notranslate"><span class="pre">SingularValueThresholding.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.SymmetricAlternatingDirectionALM"><code class="docutils literal notranslate"><span class="pre">SymmetricAlternatingDirectionALM</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.SymmetricAlternatingDirectionALM.decompose"><code class="docutils literal notranslate"><span class="pre">SymmetricAlternatingDirectionALM.decompose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompy.matrix_factorization.VariationalBayes"><code class="docutils literal notranslate"><span class="pre">VariationalBayes</span></code></a><ul>
<li><a class="reference internal" href="#decompy.matrix_factorization.VariationalBayes.decompose"><code class="docutils literal notranslate"><span class="pre">VariationalBayes.decompose()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="decompy.interfaces.html"
                          title="previous chapter">decompy.interfaces package</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="decompy.rankmethods.html"
                          title="next chapter">decompy.rankmethods package</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/decompy.matrix_factorization.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="decompy.rankmethods.html" title="decompy.rankmethods package"
             >next</a> |</li>
        <li class="right" >
          <a href="decompy.interfaces.html" title="decompy.interfaces package"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">decompy 1.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="decompy.html" >decompy package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">decompy.matrix_factorization package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Subhrajyoty Roy.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>